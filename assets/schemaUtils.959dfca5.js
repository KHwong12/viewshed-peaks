var me=Object.defineProperty,ye=Object.defineProperties;var ge=Object.getOwnPropertyDescriptors;var W=Object.getOwnPropertySymbols;var be=Object.prototype.hasOwnProperty,he=Object.prototype.propertyIsEnumerable;var H=(e,i,t)=>i in e?me(e,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[i]=t,f=(e,i)=>{for(var t in i||(i={}))be.call(i,t)&&H(e,t,i[t]);if(W)for(var t of W(i))he.call(i,t)&&H(e,t,i[t]);return e},m=(e,i)=>ye(e,ge(i));import{ag as _,oy as Y,r as B,t as ve,ev as xe,w as Se,op as Z,n5 as ee,dX as te,ae as K,E as D,pZ as M,U as h,dh as we,A as U,a_ as A,gB as ie,oX as ze,ak as Ee,lw as Fe}from"./vendor.d423bc92.js";import{A as C,E,q as Ve}from"./Utils.da429e4b.js";import{F as $e,L as F}from"./MaterialKey.155b617d.js";import{o as Ie}from"./Pipeline.b8c395b5.js";import{t as Te}from"./CIMSymbolHelper.f60c7096.js";import{l as Oe}from"./definitions.9156fef2.js";import"./number.dfbabd3f.js";import"./cimAnalyzer.0966c9e8.js";import"./SymbolProcessor.5c23495e.js";import{x as J}from"./MD5.f9440c6b.js";import"./QueryEngine.5cc290e3.js";import"./WhereClause.34680e97.js";import"./json.2d0d6862.js";import"./QueryEngineCapabilities.83e56447.js";import"./utils.be34ef8d.js";import"./ClassBreaksDefinition.5f2e3a30.js";import"./createConnection.7446f31c.js";import"./quickselect.32614045.js";import"./FeatureSetReader.7bc592c2.js";import"./centroid.d8eb382d.js";import"./ogcFeatureUtils.6a6275c8.js";import"./geojson.6e4b46ff.js";import"./clientSideDefaults.f09cd21b.js";import"./BidiEngine.8aecf25d.js";import"./tileUtils.cf31bf24.js";import"./TileClipper.5e5f403b.js";import"./GeometryUtils.b5716770.js";function je(e){if(!e)return C.NONE;let i=0;for(const t of e)if(t.type==="size"){const s=Ie(t);i|=s,t.target==="outline"&&(i|=s<<4)}else t.type==="color"?i|=C.COLOR:t.type==="opacity"?i|=C.OPACITY:t.type==="rotation"&&(i|=C.ROTATION);return i}function Me(e){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const i=e.getVisualVariablesForType("size");if(!i[0])return 0;const t=i[0];if(t.target==="outline")return 0;if(t.transformationType==="stops")return t.stops.map(s=>s.size).reduce(q,0);if(t.transformationType==="clamped-linear"){let s=-1/0,n=-1/0;return s=typeof t.maxSize=="number"?t.maxSize:t.maxSize.stops.map(l=>l.size).reduce(q,0),n=typeof t.minSize=="number"?t.minSize:t.minSize.stops.map(l=>l.size).reduce(q,0),Math.max(s,n)}return t.transformationType==="real-world-size"?30:void 0}Oe.metrics,new Te(0,0,24,24);function q(e,i){return Math.max(e,i)}const k=8,se=k-2,Ne=_.getLogger("esri.renderers.visualVariables.support.utils");function Re(e){return e.map(i=>Ce(i)?ke(i.clone()):i)}function Ce(e){return(e.type==="size"||e.type==="color"||e.type==="opacity")&&e.stops!=null}function ke(e){return e.stops=_e(e.type,e.stops),e}function T(e,i,t){return(1-t)*e+t*i}function Le(e,i){const[t,...s]=i,n=s.pop(),l=s[0].value,a=s[s.length-1].value,r=(a-l)/se,u=[];for(let o=l;o<a;o+=r){let c=0;for(;o>=s[c].value;)c++;const y=s[c],d=i[c-1],g=o-d.value,x=y.value===d.value?1:g/(y.value-d.value);if(e==="color"){const v=s[c],b=i[c-1],p=v.color.clone();p.r=T(b.color.r,p.r,x),p.g=T(b.color.g,p.g,x),p.b=T(b.color.b,p.b,x),p.a=T(b.color.a,p.a,x),u.push({value:o,color:p,label:v.label})}else if(e==="size"){const v=s[c],b=i[c-1],p=Y(v.size),R=T(Y(b.size),p,x);u.push({value:o,size:R,label:v.label})}else{const v=s[c],b=T(i[c-1].opacity,v.opacity,x);u.push({value:o,opacity:b,label:v.label})}}return[t,...u,n]}function Pe(e){const[i,...t]=e,s=t.pop();for(;t.length>se;){let n=0,l=0;for(let a=1;a<t.length;a++){const r=t[a-1],u=t[a],o=Math.abs(u.value-r.value);o>l&&(l=o,n=a)}t.splice(n,1)}return[i,...t,s]}function _e(e,i){return i.length<=k?i:(Ne.warn(`Found ${i.length} Visual Variable stops, but MapView only supports ${k}. Displayed stops will be simplified.`),i.length>2*k?Le(e,i):Pe(i))}var G;let N=G=class extends Z{writeLevels(e,i,t){for(const s in e){const n=this.levels[s];return void(i.stops=n)}}clone(){return new G({axis:this.axis,field:this.field,valueExpression:this.valueExpression,valueExpressionTitle:this.valueExpressionTitle,maxDataValue:this.maxDataValue,maxSize:ee(this.maxSize)?this.maxSize.clone():this.maxSize,minDataValue:this.minDataValue,minSize:ee(this.minSize)?this.minSize.clone():this.minSize,normalizationField:this.normalizationField,stops:this.stops&&this.stops.map(e=>e.clone()),target:this.target,useSymbolValue:this.useSymbolValue,valueRepresentation:this.valueRepresentation,valueUnit:this.valueUnit,legendOptions:this.legendOptions&&this.legendOptions.clone(),levels:te(this.levels)})}};B([ve()],N.prototype,"levels",void 0),B([xe("levels")],N.prototype,"writeLevels",null),N=G=B([Se("esri.views.2d.engine.LevelDependentSizeVariable")],N);const ne=_.getLogger("esri.views.2d.layers.support.clusterUtils");K.add("esri-cluster-arcade-enabled",!0);const Be=K("esri-cluster-arcade-enabled"),Ke=(e,i,t,s)=>{const n=i.clone();if(!Je(n))return n;if(t.fields)for(const l of t.fields)Ge(e,l);if("visualVariables"in n){const l=(n.visualVariables||[]).filter(r=>r.valueExpression!=="$view.scale"),a=De(l);l.forEach(r=>{r.type==="rotation"?r.field?r.field=O(e,r.field,"avg_angle"):r.valueExpression&&(r.field=L(e,r.valueExpression,"avg_angle"),r.valueExpression=null):r.normalizationField?(r.field=O(e,r.field,"norm",r.normalizationField),r.normalizationField=null):r.field?r.field=O(e,r.field,"avg"):(r.field=L(e,r.valueExpression,"avg"),r.valueExpression=null)}),D(a)&&!Ue(l)&&(l.push(Ae(t,s)),n.dynamicClusterSize=!0),n.visualVariables=l}switch(n.type){case"simple":break;case"unique-value":n.field?n.field=O(e,n.field,"mode"):n.valueExpression&&(n.field=L(e,n.valueExpression,"mode"),n.valueExpression=null);break;case"class-breaks":n.normalizationField?(n.field=O(e,n.field,"norm",n.normalizationField),n.normalizationField=null):n.field?n.field=O(e,n.field,"avg"):(n.field=L(e,n.valueExpression,"avg"),n.valueExpression=null)}return n},De=e=>{for(const i of e)if(i.type==="size")return i;return null},Ue=e=>{for(const i of e)if(i.field==="cluster_count")return!0;return!1},Ae=(e,i)=>{const t=[new M({value:0,size:0}),new M({value:1})];if(D(i))return new Z({field:"cluster_count",stops:[...t,new M({value:2,size:0})]});const s=Object.keys(i).reduce((n,l)=>m(f({},n),{[l]:[...t,new M({value:Math.max(2,i[l].minValue),size:e.clusterMinSize}),new M({value:Math.max(3,i[l].maxValue),size:e.clusterMaxSize})]}),{});return new N({field:"cluster_count",levels:s})},Je=e=>{const i=t=>ne.error(new h("Unsupported-renderer",t,{renderer:e}));if(e.type==="unique-value"){if(e.field2||e.field3)return i("FeatureReductionCluster does not support multi-field UniqueValueRenderers"),!1}else if(e.type==="class-breaks"){if(e.normalizationField){const t=e.normalizationType;if(t!=="field")return i(`FeatureReductionCluster does not support a normalizationType of ${t}`),!1}}else if(e.type!=="simple")return i(`FeatureReductionCluster does not support renderers of type ${e.type}`),!1;if(!Be){if("valueExpression"in e&&e.valueExpression)return i("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"),!1;if(("visualVariables"in e&&e.visualVariables||[]).some(t=>!(!("valueExpression"in t)||!t.valueExpression)))return i("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),!1}return!0};function qe(e,i,t){switch(e){case"avg":case"avg_angle":return`cluster_avg_${i}`;case"mode":return`cluster_type_${i}`;case"norm":{const s=t,n="field",l=i.toLowerCase()+",norm:"+n+","+s.toLowerCase();return"cluster_avg_"+J(l)}}}function Ge(e,i){const{name:t,outStatistic:s}=i,{onStatisticField:n,onStatisticValueExpression:l,statisticType:a}=s;if(l){const r=J(l.toLowerCase());e.push({name:t,outStatistic:{onStatisticField:r,onStatisticValueExpression:l,statisticType:a}})}else n?e.push({name:t,outStatistic:{onStatisticField:n,statisticType:a}}):ne.error(new h("mapview-unsupported-field","Unable to handle field",{field:i}))}function L(e,i,t){const s=J(i),n=t==="mode"?`cluster_type_${s}`:`cluster_avg_${s}`;return e.some(l=>l.name===n)||e.push({name:n,outStatistic:{onStatisticField:s,onStatisticValueExpression:i,statisticType:t}}),n}function O(e,i,t,s){if(i==="cluster_count"||e.some(l=>l.name===i))return i;const n=qe(t,i,s);return e.some(l=>l.name===n)||(t==="norm"?e.push({name:n,outStatistic:{onStatisticField:i,onStatisticNormalizationField:s,statisticType:t}}):e.push({name:n,outStatistic:{onStatisticField:i,statisticType:t}})),n}const Xe=new we({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryMultiPatch:"multipatch",mesh:"mesh"});function Qe(e){return Xe.toJSON(e)}const j=_.getLogger("esri.views.2d.layers.features.schemaUtils"),S="ValidationError",We={esriGeometryPoint:["above-right","above-center","above-left","center-center","center-left","center-right","below-center","below-left","below-right"],esriGeometryPolygon:["always-horizontal"],esriGeometryPolyline:["center-along"],esriGeometryMultipoint:null};function V(e){return $e(e)}function le(e){return e}function $(e){if(e.type==="line-marker"){var i;return{type:"line-marker",color:(i=e.color)==null?void 0:i.toJSON(),placement:e.placement,style:e.style}}return Fe(e.toJSON()).toJSON()}function P(e){let i=0,t=0,s=!1,n=!0,l=!0;if(U(e)&&(t=Me(e),"visualVariables"in e&&(i=je(e.visualVariables||[]),s=e.type==="dot-density"),!s)){const a=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&a.push(e.backgroundFillSymbol);for(const r of a)if(r.type==="cim"&&(n=!1),r.type==="simple-fill"||r.type==="picture-fill"){const u=r.outline;u&&u.style!=="none"&&u.style!=="solid"&&(l=!1);const o=u&&u.style!=="none"&&u.style!=="solid",c=r.type==="simple-fill"&&r.style!=="none"&&r.style!=="solid";(r.type==="picture-fill"||c||o)&&(n=!1)}}return s&&(l=!1),{vvFlags:i,maxVVSize:t,supportsOutlineFills:l,stride:{fill:s?"dot-density":n?"simple":"default"}}}function re(e,i,t){return I(e,P(i),t)}function I(e,i,t){if(!e)return null;switch(e.type){case"simple-fill":case"picture-fill":return He(e,i,t);case"simple-marker":case"picture-marker":return Ze(e,i,t);case"simple-line":return Ye(e,i,t);case"text":return et(e,i,t);case"label":return it(e,i,t);case"cim":return{type:"cim",rendererKey:i.vvFlags,data:e.data,maxVVSize:i.maxVVSize};case"CIMSymbolReference":return{type:"cim",rendererKey:i.vvFlags,data:e,maxVVSize:i.maxVVSize};case"web-style":return m(f({},$(e)),{type:"web-style",hash:e.hash(),rendererKey:i.vvFlags,maxVVSize:i.maxVVSize});default:throw new Error(`symbol not supported ${e.type}`)}}function He(e,i,t){const s=i.supportsOutlineFills,n=F(E.FILL,m(f({},i),{isOutlinedFill:s})),l=t?V(n):n,a=e.clone(),r=a.outline;i.supportsOutlineFills||(a.outline=null);const u=f({materialKey:l,hash:a.hash(),isOutlinedFill:!!i.supportsOutlineFills},$(a));if(i.supportsOutlineFills)return u;const o=[];if(o.push(u),r){const c=F(E.LINE,m(f({},i),{isOutline:!0})),y=f({materialKey:t?V(c):c,hash:r.hash()},$(r));o.push(y)}return{type:"composite-symbol",layers:o,hash:o.reduce((c,y)=>y.hash+c,"")}}function Ye(e,i,t){const s=F(E.LINE,i),n=t?V(s):s,l=e.clone(),a=l.marker;l.marker=null;const r=[];if(r.push(f({materialKey:n,hash:l.hash()},$(l))),a){var u;const o=F(E.MARKER,i),c=t?V(o):o;a.color=(u=a.color)!=null?u:l.color,r.push(f({materialKey:c,hash:a.hash(),lineWidth:l.width},$(a)))}return{type:"composite-symbol",layers:r,hash:r.reduce((o,c)=>c.hash+o,"")}}function Ze(e,i,t){const s=F(E.MARKER,i),n=t?V(s):s,l=$(e);return m(f({materialKey:n,hash:e.hash()},l),{angle:e.angle,maxVVSize:i.maxVVSize})}function et(e,i,t){const s=F(E.TEXT,i),n=t?V(s):s,l=$(e);return m(f({materialKey:n,hash:e.hash()},l),{angle:e.angle,maxVVSize:i.maxVVSize})}function tt(e,i){const t=e.labelPlacement,s=We[i];if(!e.symbol)return j.warn("No ILabelClass symbol specified."),!0;if(!s)return j.error(new h("mapview-labeling:unsupported-geometry-type",`Unable to create labels for Feature Layer, ${i} is not supported`)),!0;if(!s.some(n=>n===t)){const n=s[0];t&&j.warn(`Found invalid label placement type ${t} for ${i}. Defaulting to ${n}`),e.labelPlacement=n}return!1}function ae(e,i){const t=te(e);return t.some(s=>tt(s,i))?[]:t}function it(e,i,t){const s=e.toJSON(),n=F(E.LABEL,m(f({},i),{placement:s.labelPlacement}));return m(f({materialKey:t?V(n):n,hash:e.hash()},s),{labelPlacement:s.labelPlacement})}function Ut(e){return K("esri-2d-update-debug")&&console.debug("Created new schema",oe(e,!0)),oe(e)}function oe(e,i=!1){try{var t,s;const n=lt(e,i),l={};return n.map(a=>st(l,e,a)),{source:{definitionExpression:e.definitionExpression,fields:e.fields.map(a=>a.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(t=e.historicMoment)==null?void 0:t.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(s=e.timeExtent)==null?void 0:s.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:n,targets:l}}catch(n){if(n.fieldName===S)return j.error(n),null;throw n}}function st(e,i,t){switch(t.target){case"feature":return void de(e,ce(i),t);case"aggregate":{if(!("featureReduction"in i))return;const s=i.featureReduction;if(s.type==="selection")throw new h(S,"Mapview does not support `selection` reduction type",s);return de(e,ce(i),t),void nt(e,s,t)}}}function ue(e,i){for(const t in i){const s=i[t];if(s.target!==e.name)continue;const n=e.attributes[t];n?(n.context.mesh=n.context.mesh||s.context.mesh,n.context.storage=n.context.storage||s.context.storage):e.attributes[t]=s}return e}function ce(e){var i,t,s,n,l;return[(i=(t=A(e.filter))==null?void 0:t.toJSON())!=null?i:null,(s=(n=A((l=A(e.featureEffect))==null?void 0:l.filter))==null?void 0:n.toJSON())!=null?s:null]}function de(e,i,t){return e.feature||(e.feature={name:"feature",input:"source",filters:i,attributes:{}}),ue(e.feature,t.attributes.fields),e}function nt(e,i,t){return e.aggregate||(e.aggregate={name:"aggregate",input:"feature",filters:null,attributes:{},params:{clusterRadius:ie(i.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(ie(i.clusterMaxSize)/64),fields:t.aggregateFields}}),ue(e.aggregate,t.attributes.fields),e}function w(e,i){return i.field?z(e,m(f({},i),{type:"field",field:i.field})):i.valueExpression?z(e,m(f({},i),{type:"expression",valueExpression:i.valueExpression})):{field:null,fieldIndex:null}}function z(e,i){switch(i.type){case"expression":{const t=le(i.valueExpression);if(!e.fields[t]){const s=e.indexCount++;e.fields[t]=m(f({},i),{name:t,fieldIndex:s})}return{fieldIndex:e.fields[t].fieldIndex}}case"label-expression":{const t=le(JSON.stringify(i.label));if(!e.fields[t]){const s=e.indexCount++;e.fields[t]=m(f({},i),{name:t,fieldIndex:s})}return{fieldIndex:e.fields[t].fieldIndex}}case"field":{const t=i.field;return i.target==="aggregate"&&e.fields[t]||(e.fields[t]=m(f({},i),{name:t})),{field:t}}case"statistic":return e.fields[i.name]=f({},i),{field:i.name}}}function lt(e,i=!1){const t=new Array;let s=0;return t.push(rt(e,s++,i)),t}function X(e,i,t,s,n,l=!1){const a=z(i,{type:"label-expression",target:s,context:{mesh:!0},resultType:"string",label:{labelExpression:t.labelExpression,labelExpressionInfo:t.labelExpressionInfo?{expression:t.labelExpressionInfo.expression}:null,symbol:!!t.symbol,where:t.where}}),{fieldIndex:r}=a;return m(f({},re(t,e,l)),{fieldIndex:r,target:s,index:n})}function rt(e,i,t=!1){const s={indexCount:0,fields:{}},n="featureReduction"in e&&e.featureReduction,l=n?"aggregate":"feature";if("sublayers"in e){const a={type:"subtype",subtypeField:e.subtypeField,renderers:{},stride:{fill:"default"}},r={type:"subtype",mapping:{},target:"feature"},u={type:"subtype",classes:{}},o={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:r,mesh:{matcher:a,aggregateMatcher:null,labels:u,sortKey:null}},c=new Set;let y=0;for(const{renderer:d,subtypeCode:g,labelingInfo:x,labelsVisible:v}of e.sublayers){const b=Q(s,l,d,t),p=pe(s,l,d),R=v&&x;if("visualVariables"in d&&d.visualVariables&&d.visualVariables.length)throw new h(S,"Visual variables are currently not supported for subtype layers");if(b.type==="dictionary")throw new h(S,"Dictionary renderer is not supported in subtype layers");if(b.type==="subtype")throw new h(S,"Nested subtype renderers is not supported");if(U(p)&&p.type==="subtype")throw new h(S,"Nested subtype storage is not supported");if(U(p)&&p.type==="dot-density")throw new h(S,"Dot density attributes are not supported in subtype layers");if(c.has(g))throw new h(S,"Subtype codes for sublayers must be unique");c.add(g),a.renderers[g]=b,r.mapping[g]=p,R&&(u.classes[g]=R.map(fe=>X(d,s,fe,"feature",y++,t)))}return o}if(e.renderer.type==="heatmap"){const{blurRadius:a,fieldOffset:r,field:u}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:l,storage:null,mesh:{blurRadius:a,fieldOffset:r,field:w(s,{target:l,field:u,resultType:"numeric"}).field}}}{const a=[],r=l==="aggregate"?Ke(a,e.renderer,n,null):e.renderer;ot(s,a);const u=Q(s,l,r,t);let o=null;const c=pe(s,l,r),y=Qe(e.geometryType);let d=e.labelsVisible&&e.labelingInfo||[],g=[];if(n){if(n.type==="selection")throw new h(S,"Mapview does not support `selection` reduction type",n);if(n.symbol){const p=new ze({symbol:n.symbol,visualVariables:"visualVariables"in r?r.visualVariables:null});o=Q(s,l,p,t)}g=n&&n.labelsVisible&&n.labelingInfo||[]}d=ae(d,y),g=ae(g,y);let x=0;const v=[...d.map(p=>X(r,s,p,"feature",x++,t)),...g.map(p=>X(r,s,p,"aggregate",x++,t))],b=at(s,e.orderBy);return{type:"symbol",target:l,attributes:s,aggregateFields:a,storage:c,mesh:{matcher:u,labels:{type:"simple",classes:v},aggregateMatcher:o,sortKey:b}}}}function at(e,i){if(D(i)||!i.length)return null;i.length>1&&j.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${i.length}. All but the first will be discarded`);const t=i[0],s=t.order==="ascending"?"asc":"desc";return t.field?{field:t.field,order:s}:t.valueExpression?{fieldIndex:z(e,{type:"expression",target:"feature",valueExpression:t.valueExpression,resultType:"numeric"}).fieldIndex,order:s}:(j.error(new h(S,"Expected to find a field or valueExpression for OrderByInfo",t)),null)}function ot(e,i){const t={mesh:!0,storage:!0};for(const s of i){const{name:n,outStatistic:l}=s,{statisticType:a,onStatisticField:r}=l;let u=null,o=null,c=null;const y="numeric",d="feature";"onStatisticValueExpression"in l?o=z(e,{type:"expression",target:d,valueExpression:l.onStatisticValueExpression,resultType:y}).fieldIndex:"onStatisticNormalizationField"in l?(u=z(e,{type:"field",target:d,field:r,resultType:y}).field,c=l.onStatisticNormalizationField):u=z(e,{type:"field",target:d,field:r,resultType:y}).field,z(e,{type:"statistic",target:"aggregate",name:n,context:t,inField:u,inNormalizationField:c,inFieldIndex:o,statisticType:a})}}function pe(e,i,t){switch(t.type){case"dot-density":return ut(e,i,t.attributes);case"simple":case"class-breaks":case"unique-value":case"dictionary":return ct(e,i,t.visualVariables);case"heatmap":return null}}function ut(e,i,t){return!t||!t.length?{type:"dot-density",mapping:[],target:i}:{type:"dot-density",mapping:t.map((s,n)=>{const{field:l,fieldIndex:a}=w(e,{valueExpression:s.valueExpression,field:s.field,resultType:"numeric",target:i});return{binding:n,field:l,fieldIndex:a}}),target:i}}function ct(e,i,t){if(!t||!t.length)return{type:"visual-variable",mapping:[],target:i};const s={storage:!0},n="numeric";return{type:"visual-variable",mapping:Re(t).map(l=>{var a;const r=Ve(l.type),{field:u,fieldIndex:o}=w(e,{target:i,valueExpression:l.valueExpression,field:l.field,context:s,resultType:n});switch(l.type){case"size":return l.valueExpression==="$view.scale"?null:{type:"size",binding:r,field:u,fieldIndex:o,normalizationField:w(e,{target:i,field:l.normalizationField,context:s,resultType:n}).field,valueRepresentation:(a=l.valueRepresentation)!=null?a:null};case"color":return{type:"color",binding:r,field:u,fieldIndex:o,normalizationField:w(e,{target:i,field:l.normalizationField,context:s,resultType:n}).field};case"opacity":return{type:"opacity",binding:r,field:u,fieldIndex:o,normalizationField:w(e,{target:i,field:l.normalizationField,context:s,resultType:n}).field};case"rotation":return{type:"rotation",binding:r,field:u,fieldIndex:o}}}).filter(l=>l),target:i}}function Q(e,i,t,s=!1){const n=Ee(e,{indexCount:0,fields:{}});switch(t.type){case"simple":case"dot-density":return dt(n,t,s);case"class-breaks":return pt(n,i,t,s);case"unique-value":return ft(n,i,t,s);case"dictionary":return mt(n,t,s)}}function dt(e,i,t=!1){const s=i.getSymbols(),n=s.length?s[0]:null,{stride:l}=P(i);return{type:"simple",symbol:re(n,i,t),stride:l}}function pt(e,i,t,s=!1){const n={mesh:!0,use:"renderer.field"},l=t.backgroundFillSymbol,{field:a,fieldIndex:r}=w(e,{target:i,field:t.field,valueExpression:t.valueExpression,resultType:"numeric",context:n}),u=t.normalizationType,o=u==="log"?"esriNormalizeByLog":u==="percent-of-total"?"esriNormalizeByPercentOfTotal":u==="field"?"esriNormalizeByField":null,c=P(t),y=t.classBreakInfos.map(d=>({symbol:I(d.symbol,c,s),min:d.minValue,max:d.maxValue})).sort((d,g)=>d.min-g.min);return{type:"interval",attributes:e.fields,field:a,fieldIndex:r,backgroundFillSymbol:I(l,c,s),defaultSymbol:I(t.defaultSymbol,c,s),intervals:y,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,normalizationType:o,isMaxInclusive:t.isMaxInclusive,stride:c.stride}}function ft(e,i,t,s=!1){const n=[],l=t.backgroundFillSymbol,a={target:i,context:{mesh:!0},resultType:"string"};if(t.field&&typeof t.field!="string")throw new h(S,"Expected renderer.field to be a string",t);const{field:r,fieldIndex:u}=w(e,m(f({},a),{field:t.field,valueExpression:t.valueExpression})),o=P(t);for(const c of t.uniqueValueInfos)n.push({value:""+c.value,symbol:I(c.symbol,o,s)});return{type:"map",attributes:e.fields,field:r,fieldIndex:u,field2:w(e,m(f({},a),{field:t.field2})).field,field3:w(e,m(f({},a),{field:t.field3})).field,fieldDelimiter:t.fieldDelimiter,backgroundFillSymbol:I(l,o),defaultSymbol:I(t.defaultSymbol,o),map:n,stride:o.stride}}function mt(e,i,t=!1){return{type:"dictionary",renderer:i.toJSON(),stride:{fill:"default"}}}export{ot as addAggregateFields,Q as createMatcherSchema,Ut as createSchema,re as createSymbolSchema,P as createSymbolSchemaOptions};
