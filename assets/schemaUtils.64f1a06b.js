var fe=Object.defineProperty,me=Object.defineProperties;var ye=Object.getOwnPropertyDescriptors;var Y=Object.getOwnPropertySymbols;var ge=Object.prototype.hasOwnProperty,be=Object.prototype.propertyIsEnumerable;var Z=(e,i,t)=>i in e?fe(e,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[i]=t,f=(e,i)=>{for(var t in i||(i={}))ge.call(i,t)&&Z(e,t,i[t]);if(Y)for(var t of Y(i))be.call(i,t)&&Z(e,t,i[t]);return e},m=(e,i)=>me(e,ye(i));import{Z as U,o9 as H,e as J,d as he,eh as ve,i as xe,o0 as re,mP as Q,dJ as ae,X as j,t as X,pC as R,x as h,d2 as Se,r as q,aJ as K,gj as ee,oA as we,a1 as ze,ld as Ve}from"./index.89a7b683.js";import{A as L,E as F,q as Fe}from"./Utils.95e2f686.js";import{F as Ee,L as E}from"./MaterialKey.1a43e688.js";import{o as $e}from"./Pipeline.387ccccd.js";import{t as Ie}from"./CIMSymbolHelper.423b1eca.js";import{l as Te}from"./definitions.9156fef2.js";import"./number.dfbabd3f.js";import"./cimAnalyzer.1dd77bd0.js";import"./SymbolProcessor.71c73564.js";import{x as W}from"./MD5.f9440c6b.js";import"./QueryEngine.23601ed8.js";import"./WhereClause.1d2917c7.js";import"./json.2d0d6862.js";import"./QueryEngineCapabilities.83e56447.js";import"./utils.2d48938c.js";import"./ClassBreaksDefinition.f112ce2a.js";import"./createConnection.da7b4dd2.js";import"./quickselect.32614045.js";import"./FeatureSetReader.e1c1a420.js";import"./centroid.2275fb3f.js";import"./ogcFeatureUtils.bad25edc.js";import"./geojson.4fc1bb0e.js";import"./clientSideDefaults.5372191c.js";import"./BidiEngine.8aecf25d.js";import"./tileUtils.2e7f19fc.js";import"./TileClipper.278275c3.js";import"./GeometryUtils.b5716770.js";function Oe(e){if(!e)return L.NONE;let i=0;for(const t of e)if(t.type==="size"){const n=$e(t);i|=n,t.target==="outline"&&(i|=n<<4)}else t.type==="color"?i|=L.COLOR:t.type==="opacity"?i|=L.OPACITY:t.type==="rotation"&&(i|=L.ROTATION);return i}function Ne(e){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const i=e.getVisualVariablesForType("size");if(!i[0])return 0;const t=i[0];if(t.target==="outline")return 0;if(t.transformationType==="stops")return t.stops.map(n=>n.size).reduce(B,0);if(t.transformationType==="clamped-linear"){let n=-1/0,l=-1/0;return n=typeof t.maxSize=="number"?t.maxSize:t.maxSize.stops.map(s=>s.size).reduce(B,0),l=typeof t.minSize=="number"?t.minSize:t.minSize.stops.map(s=>s.size).reduce(B,0),Math.max(n,l)}return t.transformationType==="real-world-size"?30:void 0}Te.metrics,new Ie(0,0,24,24);function B(e,i){return Math.max(e,i)}const P=8,oe=P-2,Re=U.getLogger("esri.renderers.visualVariables.support.utils");function Me(e){return e.map(i=>ke(i)?Le(i.clone()):i)}function ke(e){return(e.type==="size"||e.type==="color"||e.type==="opacity")&&e.stops!=null}function Le(e){return e.stops=_e(e.type,e.stops),e}function T(e,i,t){return(1-t)*e+t*i}function Ce(e,i){const[t,...n]=i,l=n.pop(),s=n[0].value,a=n[n.length-1].value,r=(a-s)/oe,u=[];for(let o=s;o<a;o+=r){let c=0;for(;o>=n[c].value;)c++;const y=n[c],d=i[c-1],g=o-d.value,x=y.value===d.value?1:g/(y.value-d.value);if(e==="color"){const v=n[c],b=i[c-1],p=v.color.clone();p.r=T(b.color.r,p.r,x),p.g=T(b.color.g,p.g,x),p.b=T(b.color.b,p.b,x),p.a=T(b.color.a,p.a,x),u.push({value:o,color:p,label:v.label})}else if(e==="size"){const v=n[c],b=i[c-1],p=H(v.size),k=T(H(b.size),p,x);u.push({value:o,size:k,label:v.label})}else{const v=n[c],b=T(i[c-1].opacity,v.opacity,x);u.push({value:o,opacity:b,label:v.label})}}return[t,...u,l]}function Pe(e){const[i,...t]=e,n=t.pop();for(;t.length>oe;){let l=0,s=0;for(let a=1;a<t.length;a++){const r=t[a-1],u=t[a],o=Math.abs(u.value-r.value);o>s&&(s=o,l=a)}t.splice(l,1)}return[i,...t,n]}function _e(e,i){return i.length<=P?i:(Re.warn(`Found ${i.length} Visual Variable stops, but MapView only supports ${P}. Displayed stops will be simplified.`),i.length>2*P?Ce(e,i):Pe(i))}var G;let M=G=class extends re{writeLevels(e,i,t){for(const n in e){const l=this.levels[n];return void(i.stops=l)}}clone(){return new G({axis:this.axis,field:this.field,valueExpression:this.valueExpression,valueExpressionTitle:this.valueExpressionTitle,maxDataValue:this.maxDataValue,maxSize:Q(this.maxSize)?this.maxSize.clone():this.maxSize,minDataValue:this.minDataValue,minSize:Q(this.minSize)?this.minSize.clone():this.minSize,normalizationField:this.normalizationField,stops:this.stops&&this.stops.map(e=>e.clone()),target:this.target,useSymbolValue:this.useSymbolValue,valueRepresentation:this.valueRepresentation,valueUnit:this.valueUnit,legendOptions:this.legendOptions&&this.legendOptions.clone(),levels:ae(this.levels)})}};J([he()],M.prototype,"levels",void 0),J([ve("levels")],M.prototype,"writeLevels",null),M=G=J([xe("esri.views.2d.engine.LevelDependentSizeVariable")],M);const ue=U.getLogger("esri.views.2d.layers.support.clusterUtils");j.add("esri-cluster-arcade-enabled",!0);const Je=j("esri-cluster-arcade-enabled"),Ke=(e,i,t,n)=>{const l=i.clone();if(!qe(l))return l;if(t.fields)for(const s of t.fields)Ue(e,s);if("visualVariables"in l){const s=(l.visualVariables||[]).filter(r=>r.valueExpression!=="$view.scale"),a=Be(s);s.forEach(r=>{r.type==="rotation"?r.field?r.field=O(e,r.field,"avg_angle"):r.valueExpression&&(r.field=C(e,r.valueExpression,"avg_angle"),r.valueExpression=null):r.normalizationField?(r.field=O(e,r.field,"norm",r.normalizationField),r.normalizationField=null):r.field?r.field=O(e,r.field,"avg"):(r.field=C(e,r.valueExpression,"avg"),r.valueExpression=null)}),X(a)&&!Ae(s)&&(s.push(De(t,n)),l.dynamicClusterSize=!0),l.visualVariables=s}switch(l.type){case"simple":break;case"unique-value":l.field?l.field=O(e,l.field,"mode"):l.valueExpression&&(l.field=C(e,l.valueExpression,"mode"),l.valueExpression=null);break;case"class-breaks":l.normalizationField?(l.field=O(e,l.field,"norm",l.normalizationField),l.normalizationField=null):l.field?l.field=O(e,l.field,"avg"):(l.field=C(e,l.valueExpression,"avg"),l.valueExpression=null)}return l},Be=e=>{for(const i of e)if(i.type==="size")return i;return null},Ae=e=>{for(const i of e)if(i.field==="cluster_count")return!0;return!1},De=(e,i)=>{const t=[new R({value:0,size:0}),new R({value:1})];if(X(i))return new re({field:"cluster_count",stops:[...t,new R({value:2,size:0})]});const n=Object.keys(i).reduce((l,s)=>m(f({},l),{[s]:[...t,new R({value:Math.max(2,i[s].minValue),size:e.clusterMinSize}),new R({value:Math.max(3,i[s].maxValue),size:e.clusterMaxSize})]}),{});return new M({field:"cluster_count",levels:n})},qe=e=>{const i=t=>ue.error(new h("Unsupported-renderer",t,{renderer:e}));if(e.type==="unique-value"){if(e.field2||e.field3)return i("FeatureReductionCluster does not support multi-field UniqueValueRenderers"),!1}else if(e.type==="class-breaks"){if(e.normalizationField){const t=e.normalizationType;if(t!=="field")return i(`FeatureReductionCluster does not support a normalizationType of ${t}`),!1}}else if(e.type!=="simple")return i(`FeatureReductionCluster does not support renderers of type ${e.type}`),!1;if(!Je){if("valueExpression"in e&&e.valueExpression)return i("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"),!1;if(("visualVariables"in e&&e.visualVariables||[]).some(t=>!(!("valueExpression"in t)||!t.valueExpression)))return i("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),!1}return!0};function Ge(e,i,t){switch(e){case"avg":case"avg_angle":return`cluster_avg_${i}`;case"mode":return`cluster_type_${i}`;case"norm":{const n=t,l="field",s=i.toLowerCase()+",norm:"+l+","+n.toLowerCase();return"cluster_avg_"+W(s)}}}function Ue(e,i){const{name:t,outStatistic:n}=i,{onStatisticField:l,onStatisticValueExpression:s,statisticType:a}=n;if(s){const r=W(s.toLowerCase());e.push({name:t,outStatistic:{onStatisticField:r,onStatisticValueExpression:s,statisticType:a}})}else l?e.push({name:t,outStatistic:{onStatisticField:l,statisticType:a}}):ue.error(new h("mapview-unsupported-field","Unable to handle field",{field:i}))}function C(e,i,t){const n=W(i),l=t==="mode"?`cluster_type_${n}`:`cluster_avg_${n}`;return e.some(s=>s.name===l)||e.push({name:l,outStatistic:{onStatisticField:n,onStatisticValueExpression:i,statisticType:t}}),l}function O(e,i,t,n){if(i==="cluster_count"||e.some(s=>s.name===i))return i;const l=Ge(t,i,n);return e.some(s=>s.name===l)||(t==="norm"?e.push({name:l,outStatistic:{onStatisticField:i,onStatisticNormalizationField:n,statisticType:t}}):e.push({name:l,outStatistic:{onStatisticField:i,statisticType:t}})),l}const je=new Se({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryMultiPatch:"multipatch",mesh:"mesh"});function Xe(e){return je.toJSON(e)}const N=U.getLogger("esri.views.2d.layers.features.schemaUtils"),S="ValidationError",We={esriGeometryPoint:["above-right","above-center","above-left","center-center","center-left","center-right","below-center","below-left","below-right"],esriGeometryPolygon:["always-horizontal"],esriGeometryPolyline:["center-along"],esriGeometryMultipoint:null};function $(e){return Ee(e)}function I(e){if(e.type==="line-marker"){var i;return{type:"line-marker",color:(i=e.color)==null?void 0:i.toJSON(),placement:e.placement,style:e.style}}return Ve(e.toJSON()).toJSON()}function _(e){let i=0,t=0,n=!1,l=!0,s=!0;if(q(e)&&(t=Ne(e),"visualVariables"in e&&(i=Oe(e.visualVariables||[]),n=e.type==="dot-density"),!n)){const a=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&a.push(e.backgroundFillSymbol);for(const r of a)if(r.type==="cim"&&(l=!1),r.type==="simple-fill"||r.type==="picture-fill"){const u=r.outline;u&&u.style!=="none"&&u.style!=="solid"&&(s=!1);const o=u&&u.style!=="none"&&u.style!=="solid",c=r.type==="simple-fill"&&r.style!=="none"&&r.style!=="solid";(r.type==="picture-fill"||c||o)&&(l=!1)}}return n&&(s=!1),{vvFlags:i,maxVVSize:t,supportsOutlineFills:s,stride:{fill:n?"dot-density":l?"simple":"default"}}}function ce(e,i,t){return V(e,_(i),t)}function V(e,i,t){if(!e)return null;switch(e.type){case"simple-fill":case"picture-fill":return Ye(e,i,t);case"simple-marker":case"picture-marker":return He(e,i,t);case"simple-line":return Ze(e,i,t);case"text":return Qe(e,i,t);case"label":return tt(e,i,t);case"cim":return{type:"cim",rendererKey:i.vvFlags,data:e.data,maxVVSize:i.maxVVSize};case"CIMSymbolReference":return{type:"cim",rendererKey:i.vvFlags,data:e,maxVVSize:i.maxVVSize};case"web-style":return m(f({},I(e)),{type:"web-style",hash:e.hash(),rendererKey:i.vvFlags,maxVVSize:i.maxVVSize});default:throw new Error(`symbol not supported ${e.type}`)}}function Ye(e,i,t){const n=i.supportsOutlineFills,l=E(F.FILL,m(f({},i),{isOutlinedFill:n})),s=t?$(l):l,a=e.clone(),r=a.outline;i.supportsOutlineFills||(a.outline=null);const u=f({materialKey:s,hash:a.hash(),isOutlinedFill:!!i.supportsOutlineFills},I(a));if(i.supportsOutlineFills)return u;const o=[];if(o.push(u),r){const c=E(F.LINE,m(f({},i),{isOutline:!0})),y=f({materialKey:t?$(c):c,hash:r.hash()},I(r));o.push(y)}return{type:"composite-symbol",layers:o,hash:o.reduce((c,y)=>y.hash+c,"")}}function Ze(e,i,t){const n=E(F.LINE,i),l=t?$(n):n,s=e.clone(),a=s.marker;s.marker=null;const r=[];if(r.push(f({materialKey:l,hash:s.hash()},I(s))),a){var u;const o=E(F.MARKER,i),c=t?$(o):o;a.color=(u=a.color)!=null?u:s.color,r.push(f({materialKey:c,hash:a.hash(),lineWidth:s.width},I(a)))}return{type:"composite-symbol",layers:r,hash:r.reduce((o,c)=>c.hash+o,"")}}function He(e,i,t){const n=E(F.MARKER,i),l=t?$(n):n,s=I(e);return m(f({materialKey:l,hash:e.hash()},s),{angle:e.angle,maxVVSize:i.maxVVSize})}function Qe(e,i,t){const n=E(F.TEXT,i),l=t?$(n):n,s=I(e);return m(f({materialKey:l,hash:e.hash()},s),{angle:e.angle,maxVVSize:i.maxVVSize})}function et(e,i){const t=e.labelPlacement,n=We[i];if(!e.symbol)return N.warn("No ILabelClass symbol specified."),!0;if(!n)return N.error(new h("mapview-labeling:unsupported-geometry-type",`Unable to create labels for Feature Layer, ${i} is not supported`)),!0;if(!n.some(l=>l===t)){const l=n[0];t&&N.warn(`Found invalid label placement type ${t} for ${i}. Defaulting to ${l}`),e.labelPlacement=l}return!1}function te(e,i){const t=ae(e);return t.some(n=>et(n,i))?[]:t}function tt(e,i,t){const n=e.toJSON(),l=E(F.LABEL,m(f({},i),{placement:n.labelPlacement}));return m(f({materialKey:t?$(l):l,hash:e.hash()},n),{labelPlacement:n.labelPlacement})}function At(e){return j("esri-2d-update-debug")&&console.debug("Created new schema",ie(e,!0)),ie(e)}function ie(e,i=!1){try{var t,n;const l=lt(e,i),s={};return l.map(a=>it(s,e,a)),{source:{definitionExpression:e.definitionExpression,fields:e.fields.map(a=>a.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(t=e.historicMoment)==null?void 0:t.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(n=e.timeExtent)==null?void 0:n.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:l,targets:s}}catch(l){if(l.fieldName===S)return N.error(l),null;throw l}}function it(e,i,t){switch(t.target){case"feature":return void le(e,ne(i),t);case"aggregate":{if(!("featureReduction"in i))return;const n=i.featureReduction;if(n.type==="selection")throw new h(S,"Mapview does not support `selection` reduction type",n);return le(e,ne(i),t),void nt(e,n,t)}}}function de(e,i){for(const t in i){const n=i[t];if(n.target!==e.name)continue;const l=e.attributes[t];l?(l.context.mesh=l.context.mesh||n.context.mesh,l.context.storage=l.context.storage||n.context.storage):e.attributes[t]=n}return e}function ne(e){var i,t,n,l,s;return[(i=(t=K(e.filter))==null?void 0:t.toJSON())!=null?i:null,(n=(l=K((s=K(e.featureEffect))==null?void 0:s.filter))==null?void 0:l.toJSON())!=null?n:null]}function le(e,i,t){return e.feature||(e.feature={name:"feature",input:"source",filters:i,attributes:{}}),de(e.feature,t.attributes.fields),e}function nt(e,i,t){return e.aggregate||(e.aggregate={name:"aggregate",input:"feature",filters:null,attributes:{},params:{clusterRadius:ee(i.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(ee(i.clusterMaxSize)/64),fields:t.aggregateFields}}),de(e.aggregate,t.attributes.fields),e}function w(e,i){return i.field?z(e,m(f({},i),{type:"field",field:i.field})):i.valueExpression?z(e,m(f({},i),{type:"expression",valueExpression:i.valueExpression})):{field:null,fieldIndex:null}}function z(e,i){switch(i.type){case"expression":{const t=i.valueExpression;if(!e.fields[t]){const n=e.indexCount++;e.fields[t]=m(f({},i),{name:t,fieldIndex:n})}return{fieldIndex:e.fields[t].fieldIndex}}case"label-expression":{const t=JSON.stringify(i.label);if(!e.fields[t]){const n=e.indexCount++;e.fields[t]=m(f({},i),{name:t,fieldIndex:n})}return{fieldIndex:e.fields[t].fieldIndex}}case"field":{const t=i.field;return i.target==="aggregate"&&e.fields[t]||(e.fields[t]=m(f({},i),{name:t})),{field:t}}case"statistic":return e.fields[i.name]=f({},i),{field:i.name}}}function lt(e,i=!1){const t=new Array;let n=0;return t.push(st(e,n++,i)),t}function A(e,i,t,n,l,s=!1){const a=z(i,{type:"label-expression",target:n,context:{mesh:!0},resultType:"string",label:{labelExpression:t.labelExpression,labelExpressionInfo:t.labelExpressionInfo?{expression:t.labelExpressionInfo.expression}:null,symbol:!!t.symbol,where:t.where}}),{fieldIndex:r}=a;return m(f({},ce(t,e,s)),{fieldIndex:r,target:n,index:l})}function st(e,i,t=!1){const n={indexCount:0,fields:{}},l="featureReduction"in e&&e.featureReduction,s=l?"aggregate":"feature";if("sublayers"in e){const a={type:"subtype",subtypeField:e.subtypeField,renderers:{},stride:{fill:"default"}},r={type:"subtype",mapping:{},target:"feature"},u={type:"subtype",classes:{}},o={type:"symbol",target:"feature",aggregateFields:[],attributes:n,storage:r,mesh:{matcher:a,aggregateMatcher:null,labels:u,sortKey:null}},c=new Set;let y=0;for(const{renderer:d,subtypeCode:g,labelingInfo:x,labelsVisible:v}of e.sublayers){const b=D(n,s,d,t),p=se(n,s,d),k=v&&x;if("visualVariables"in d&&d.visualVariables&&d.visualVariables.length)throw new h(S,"Visual variables are currently not supported for subtype layers");if(b.type==="dictionary")throw new h(S,"Dictionary renderer is not supported in subtype layers");if(b.type==="subtype")throw new h(S,"Nested subtype renderers is not supported");if(q(p)&&p.type==="subtype")throw new h(S,"Nested subtype storage is not supported");if(q(p)&&p.type==="dot-density")throw new h(S,"Dot density attributes are not supported in subtype layers");if(c.has(g))throw new h(S,"Subtype codes for sublayers must be unique");c.add(g),a.renderers[g]=b,r.mapping[g]=p,k&&(u.classes[g]=k.map(pe=>A(d,n,pe,"feature",y++,t)))}return o}if(e.renderer.type==="heatmap"){const{blurRadius:a,fieldOffset:r,field:u}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:n,target:s,storage:null,mesh:{blurRadius:a,fieldOffset:r,field:w(n,{target:s,field:u,resultType:"numeric"}).field}}}{const a=[],r=s==="aggregate"?Ke(a,e.renderer,l,null):e.renderer;at(n,a);const u=D(n,s,r,t);let o=null;const c=se(n,s,r),y=Xe(e.geometryType);let d=e.labelsVisible&&e.labelingInfo||[],g=[];if(l){if(l.type==="selection")throw new h(S,"Mapview does not support `selection` reduction type",l);if(l.symbol){const p=new we({symbol:l.symbol,visualVariables:"visualVariables"in r?r.visualVariables:null});o=D(n,s,p,t)}g=l&&l.labelsVisible&&l.labelingInfo||[]}d=te(d,y),g=te(g,y);let x=0;const v=[...d.map(p=>A(r,n,p,"feature",x++,t)),...g.map(p=>A(r,n,p,"aggregate",x++,t))],b=rt(n,e.orderBy);return{type:"symbol",target:s,attributes:n,aggregateFields:a,storage:c,mesh:{matcher:u,labels:{type:"simple",classes:v},aggregateMatcher:o,sortKey:b}}}}function rt(e,i){if(X(i)||!i.length)return null;i.length>1&&N.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${i.length}. All but the first will be discarded`);const t=i[0],n=t.order==="ascending"?"asc":"desc";return t.field?{field:t.field,order:n}:t.valueExpression?{fieldIndex:z(e,{type:"expression",target:"feature",valueExpression:t.valueExpression,resultType:"numeric"}).fieldIndex,order:n}:(N.error(new h(S,"Expected to find a field or valueExpression for OrderByInfo",t)),null)}function at(e,i){const t={mesh:!0,storage:!0};for(const n of i){const{name:l,outStatistic:s}=n,{statisticType:a,onStatisticField:r}=s;let u=null,o=null,c=null;const y="numeric",d="feature";"onStatisticValueExpression"in s?o=z(e,{type:"expression",target:d,valueExpression:s.onStatisticValueExpression,resultType:y}).fieldIndex:"onStatisticNormalizationField"in s?(u=z(e,{type:"field",target:d,field:r,resultType:y}).field,c=s.onStatisticNormalizationField):u=z(e,{type:"field",target:d,field:r,resultType:y}).field,z(e,{type:"statistic",target:"aggregate",name:l,context:t,inField:u,inNormalizationField:c,inFieldIndex:o,statisticType:a})}}function se(e,i,t){switch(t.type){case"dot-density":return ot(e,i,t.attributes);case"simple":case"class-breaks":case"unique-value":case"dictionary":return ut(e,i,t.visualVariables);case"heatmap":return null}}function ot(e,i,t){return!t||!t.length?{type:"dot-density",mapping:[],target:i}:{type:"dot-density",mapping:t.map((n,l)=>{const{field:s,fieldIndex:a}=w(e,{valueExpression:n.valueExpression,field:n.field,resultType:"numeric",target:i});return{binding:l,field:s,fieldIndex:a}}),target:i}}function ut(e,i,t){if(!t||!t.length)return{type:"visual-variable",mapping:[],target:i};const n={storage:!0},l="numeric";return{type:"visual-variable",mapping:Me(t).map(s=>{var a;const r=Fe(s.type),{field:u,fieldIndex:o}=w(e,{target:i,valueExpression:s.valueExpression,field:s.field,context:n,resultType:l});switch(s.type){case"size":return s.valueExpression==="$view.scale"?null:{type:"size",binding:r,field:u,fieldIndex:o,normalizationField:w(e,{target:i,field:s.normalizationField,context:n,resultType:l}).field,valueRepresentation:(a=s.valueRepresentation)!=null?a:null};case"color":return{type:"color",binding:r,field:u,fieldIndex:o,normalizationField:w(e,{target:i,field:s.normalizationField,context:n,resultType:l}).field};case"opacity":return{type:"opacity",binding:r,field:u,fieldIndex:o,normalizationField:w(e,{target:i,field:s.normalizationField,context:n,resultType:l}).field};case"rotation":return{type:"rotation",binding:r,field:u,fieldIndex:o}}}).filter(s=>s),target:i}}function D(e,i,t,n=!1){const l=ze(e,{indexCount:0,fields:{}});switch(t.type){case"simple":case"dot-density":return ct(l,t,n);case"class-breaks":return dt(l,i,t,n);case"unique-value":return pt(l,i,t,n);case"dictionary":return ft(l,t,n)}}function ct(e,i,t=!1){const n=i.getSymbols(),l=n.length?n[0]:null,{stride:s}=_(i);return{type:"simple",symbol:ce(l,i,t),stride:s}}function dt(e,i,t,n=!1){const l={mesh:!0,use:"renderer.field"},s=t.backgroundFillSymbol,{field:a,fieldIndex:r}=w(e,{target:i,field:t.field,valueExpression:t.valueExpression,resultType:"numeric",context:l}),u=t.normalizationType,o=u==="log"?"esriNormalizeByLog":u==="percent-of-total"?"esriNormalizeByPercentOfTotal":u==="field"?"esriNormalizeByField":null,c=_(t),y=t.classBreakInfos.map(d=>({symbol:V(d.symbol,c,n),min:d.minValue,max:d.maxValue})).sort((d,g)=>d.min-g.min);return{type:"interval",attributes:e.fields,field:a,fieldIndex:r,backgroundFillSymbol:V(s,c,n),defaultSymbol:V(t.defaultSymbol,c,n),intervals:y,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,normalizationType:o,isMaxInclusive:t.isMaxInclusive,stride:c.stride}}function pt(e,i,t,n=!1){const l=[],s=t.backgroundFillSymbol,a={target:i,context:{mesh:!0},resultType:"string"};if(t.field&&typeof t.field!="string")throw new h(S,"Expected renderer.field to be a string",t);const{field:r,fieldIndex:u}=w(e,m(f({},a),{field:t.field,valueExpression:t.valueExpression})),o=_(t);for(const c of t.uniqueValueInfos)l.push({value:""+c.value,symbol:V(c.symbol,o,n)});return{type:"map",attributes:e.fields,field:r,fieldIndex:u,field2:w(e,m(f({},a),{field:t.field2})).field,field3:w(e,m(f({},a),{field:t.field3})).field,fieldDelimiter:t.fieldDelimiter,backgroundFillSymbol:V(s,o),defaultSymbol:V(t.defaultSymbol,o),map:l,stride:o.stride}}function ft(e,i,t=!1){return{type:"dictionary",renderer:i.toJSON(),stride:{fill:"default"}}}export{at as addAggregateFields,D as createMatcherSchema,At as createSchema,ce as createSymbolSchema,_ as createSymbolSchemaOptions};
