var Oe=Object.defineProperty,Ae=Object.defineProperties;var Le=Object.getOwnPropertyDescriptors;var ce=Object.getOwnPropertySymbols;var Ve=Object.prototype.hasOwnProperty,Te=Object.prototype.propertyIsEnumerable;var de=(e,t,i)=>t in e?Oe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Z=(e,t)=>{for(var i in t||(t={}))Ve.call(t,i)&&de(e,i,t[i]);if(ce)for(var i of ce(t))Te.call(t,i)&&de(e,i,t[i]);return e},Q=(e,t)=>Ae(e,Le(t));import{e as n,d as o,i as R,p as S,a7 as y,dJ as X,iw as Ie,hr as Ee,ix as $e,iy as me,_ as Re,iz as Se,iA as Pe,iB as ze,t as A,ho as E,e5 as De,aA as M,iC as He,iD as te,iE as xe,iF as oe,r as g,O as Ge,fs as Fe,h4 as re,az as W,g3 as fe,M as Ce,l as Be,ab as je,u as ae,an as Y,a4 as I,e7 as q,iG as N,aB as Ne,cK as ue,a1 as be,hg as Ue,iH as he,ck as U,hL as C,e9 as Me,iI as ke,a_ as K,iJ as ye,ao as F,a6 as We,iK as pe,hM as $,iL as we,iM as Je,bj as qe,iN as Ke,a as u,o as Ze,f as k,it as m,cp as Qe,cd as Xe,dj as Ye}from"./index.89a7b683.js";import{m as ie,p as et}from"./LineVisualElement.47192886.js";let H=class extends S{constructor(e){super(e),this.elevationAlignedTargetLocation=null,this.inputPoints={isValid:!1,observer:y(),observerSurfaceNormal:null,target:y(),targetSurfaceNormal:null,observerAdjusted:y(),targetAdjusted:y()},this.computationResult={start:y(),end:y(),intersection:y(),isValid:!1,isTargetVisible:!1},this.result=null}updateComputationResults(){this.notifyChange("computationResult")}updateInputPoints(){this.notifyChange("inputPoints")}onElevationChange(){this.notifyChange("elevationAlignedTargetLocation")}};n([o()],H.prototype,"target",void 0),n([o()],H.prototype,"elevationAlignedTargetLocation",void 0),n([o()],H.prototype,"inputPoints",void 0),n([o()],H.prototype,"computationResult",void 0),n([o()],H.prototype,"result",void 0),H=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightAnalysis")],H);var le;let T=le=class extends S{constructor(e){super(e)}clone(){return new le({type:this.type,id:X(this.id),point:X(this.point),normal:X(this.normal),ray:X(this.ray)})}equals(e){return this.type===e.type&&this.id===e.id&&Ie(this.point,e.point)&&Ee(this.normal,e.normal)&&$e(this.ray,e.ray)}};n([o()],T.prototype,"type",void 0),n([o({constructOnly:!0})],T.prototype,"id",void 0),n([o({constructOnly:!0})],T.prototype,"point",void 0),n([o({constructOnly:!0})],T.prototype,"normal",void 0),n([o({constructOnly:!0})],T.prototype,"ray",void 0),T=le=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightIntersectionResult")],T);let J=class extends S{constructor(e){super(e)}initialize(){this.intersector=Re(this.view.state.viewingMode),this.intersector.options.hud=!1,this.intersector.options.store=0}getScreenPointIntersection(e){const t=Se(e,Pe.get()),i=ze(this.view.state.camera,t,ne);return this._getRayIntersection(i)}_getRayIntersection(e){if(A(e))return null;this.view.sceneIntersectionHelper.intersectToolIntersectorRay(e,this.intersector);const t=this.intersector.results.min;if(!t.getIntersectionPoint(se))return null;const i=this.view.renderCoordsHelper.fromRenderCoords(se,this.view.spatialReference),s=E(t.normal),r=De(s,e.direction)>0?-1:1;if(M(s,s,r),He(t))return new T({type:0,id:`${t.target.layerUid}/${t.target.nodeIndex}/${t.target.componentIndex}`,point:i,normal:s,ray:te(e)});if(xe(t))return new T({type:2,id:t.target.lij.slice(),point:i,normal:s,ray:te(e)});const l=oe(t,this.view);if(g(l)){const a=l.layer,d=l.sourceLayer;let h;return d&&d.type==="scene"?h=Ge(l,d.objectIdField):h=l.uid,new T({type:0,id:`${a.uid}/${h}`,point:i,normal:s,ray:te(e)})}return null}_canUpdateFromIntersectionResult(e,t){if(A(e)||!t||e.type!==t.type)return!1;switch(e.type){case 2:{const i=e.id,s=t.id;return i[0]===s[0]&&i[1]===s[1]&&i[2]===s[2]||Fe(i,s)}case 0:case 4:return e.id===t.id}}updateFromIntersectionResult(e){let t;if(e.type===2&&g(e.point)){const i=se,s=tt,r=it;this.view.renderCoordsHelper.toRenderCoords(e.point,s),this.view.renderCoordsHelper.worldUpAtPosition(s,r);const l=this.view.basemapTerrain.elevationBounds,a=this.view.renderCoordsHelper.getAltitude(s),d=l?Math.abs(l.max-l.min)/Math.abs(a):100,h=a>0?1:-1;re(r,r),M(r,r,h*d),W(i,s,r),fe(i,s,ne),t=this._getRayIntersection(ne)}else t=this._getRayIntersection(e.ray);return this._canUpdateFromIntersectionResult(t,e)?t.point:null}};n([o()],J.prototype,"view",void 0),n([o()],J.prototype,"intersector",void 0),J=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightRayIntersector")],J);const se=y(),tt=y(),it=y(),ne=me();let x=class extends S{constructor(e){super(e),this.target=null,this.intersectedGraphic=null,this.intersectedLocation=null,this.elevationAlignedTargetLocation=null}};n([o()],x.prototype,"target",void 0),n([o()],x.prototype,"intersectedGraphic",void 0),n([o()],x.prototype,"intersectedLocation",void 0),n([o()],x.prototype,"elevationAlignedTargetLocation",void 0),n([o()],x.prototype,"visible",void 0),x=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightResult")],x);let f=class extends Ce.EventedMixin(S){constructor(e){super(e),this._updatingHandles=new Be,this._frameTask=je,this._handles=new ae,this._analysisHandles=new ae}initialize(){var e;const t=(e=this.view.resourceController)==null?void 0:e.scheduler;t&&(this._frameTask=t.registerTask(Y.LINE_OF_SIGHT_TOOL)),this._handles.add([this._connectObserver(),this._connectAnalyses(),this._connectTargets()]),this._intersector=new J({view:this.view})}destroy(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(e){this._frameTask.priority=e}get _analyses(){return this.analysisViewData.analyses}get _observerEngineLocation(){return this.analysisViewData.observerEngineLocation}set _observerEngineLocation(e){this.analysisViewData.observerEngineLocation=e}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(e){const{inputPoints:t}=e;return{inputPoints:t}}computeAnalysis(e){const t=e.analysis,{inputPoints:i,computationResult:s}=t,{observerAdjusted:r,targetAdjusted:l}=i,{start:a,end:d}=s;I(a,r),I(d,l),this._canComputeAnalysis(t)?this._computeAnalysisIntersection(e):this._interpolateAnalysisIntersection(e),t.updateComputationResults(),this.emit("result-changed",{target:e.analysis.target,result:t.result})}_adjustStartEndPositions(e){const t=this._screenPixelSize,i=this.view,{inputPoints:s}=e,{observer:r,observerSurfaceNormal:l,target:a,targetSurfaceNormal:d,observerAdjusted:h,targetAdjusted:_}=s,c=ee;g(l)?I(c,l):q(c,a,r);const v=t;re(c,c),M(c,c,Math.min(v,1)),W(h,r,c),g(d)?I(c,d):q(c,r,a);const L=i.state.camera.computeScreenPixelSizeAt(a);re(c,c),M(c,c,Math.min(L,1)),W(_,a,c)}_computeAnalysisIntersection({analysis:e,interpolationInfo:t}){const{view:i}=this,{sceneIntersectionHelper:s,renderCoordsHelper:r}=i;if(A(s))return;const l=this._intersector.intersector,{computationResult:a,inputPoints:d}=e,{observer:h,target:_}=d,{start:c,end:v}=a,L=fe(c,v,nt);s.intersectToolIntersectorRay(L,l);const P=a.intersection,B=ee,j=l.results.min.getIntersectionPoint(P);let p=!0;if(j){I(t.originalIntersection,P),I(t.originalObserver,c),I(t.originalTarget,v),r.fromRenderCoords(P,B,i.spatialReference);const b=1-N(v,_)/N(c,_);p=N(h,P)>=b*N(h,_)}const z=new Ne(B,i.spatialReference);{const{result:b,target:D}=e;g(b)?(b.target=D,b.intersectedGraphic=p?null:oe(l.results.min,i),b.intersectedLocation=p?null:z,b.visible=!!j&&p):e.result=new x({target:D,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:p?null:oe(l.results.min,i),intersectedLocation:p?null:z,visible:!!j&&p})}a.isValid=d.isValid=!0,a.isTargetVisible=p}_interpolateAnalysisIntersection({analysis:e,interpolationInfo:t}){const{computationResult:i,inputPoints:s}=e,{start:r,end:l,intersection:a}=i,{originalIntersection:d,originalObserver:h,originalTarget:_}=t;if(I(a,d),s.isValid){const c=ee,v=N(h,d)/N(h,_);ue(c,r,h),M(c,c,1-v),W(a,a,c),ue(c,l,_),M(c,c,v),W(a,a,c),i.isValid=!0}else e.result=null,i.isValid=!1,i.isTargetVisible=!1}_canComputeAnalysis(e){const t=this.analysisViewData.elevationAlignedObserver,i=this.view.frustum;if(A(t)||A(e.target)||A(i))return!1;const{observerAdjusted:s,targetAdjusted:r}=e.inputPoints,l=i.intersectsPoint(s),a=i.intersectsPoint(r);return l&&a}_onObserverChange(e,t){if(A(e))return this.analysis.targets.removeAll(),void(this.analysisViewData.elevationAlignedObserver=null);this.analysisViewData.elevationAlignedObserver=this._applyElevationAlignment(e,t);const i=y();this.view.renderCoordsHelper.toRenderCoords(this.analysisViewData.elevationAlignedObserver,i),this._observerEngineLocation=i,this.priority=Y.LINE_OF_SIGHT_TOOL_INTERACTIVE}_applyElevationAlignment(e,t){if(e.hasZ&&(A(t)||t.type===0))return e;const i=e.clone();return i.z=be(Ue(this.view.elevationProvider,i),0),i}_onObserverChangeForAnalysis(e){e.inputPoints.isValid=!1}_onObserverEngineForAnalysis(e,t,i){const{inputPoints:s}=e;if(I(s.observer,t),g(i)){const r=this._intersector.updateFromIntersectionResult(i);g(r)&&this.view.renderCoordsHelper.toRenderCoords(r,s.observer),s.observerSurfaceNormal=he(i.normal)}else s.observerSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=Y.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetLocationChange(e,t,i){const s=e.inputPoints;if(s.isValid=!1,g(t)){if(e.elevationAlignedTargetLocation=this._applyElevationAlignment(t,i),this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,s.target),g(i)){const r=this._intersector.updateFromIntersectionResult(i);g(r)&&this.view.renderCoordsHelper.toRenderCoords(r,s.target),s.targetSurfaceNormal=he(i.normal)}else s.targetSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints()}this.priority=Y.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectAnalysisToTarget(e){return U([C(()=>e.target.location,t=>{ve(t,e.target.intersection)||(e.target.intersection=null)},pe),C(()=>({analysis:e,targetLocation:e.target.location,targetIntersection:e.target.intersection}),({analysis:t,targetLocation:i,targetIntersection:s})=>{g(i)&&this._onTargetLocationChange(t,i,s)},$)])}_connectAnalysisToObserver(e){return C(()=>({analysis:e,observer:this.analysisViewData.elevationAlignedObserver}),({analysis:t})=>{this._onObserverChangeForAnalysis(t)},$)}_connectAnalysisToObserverEngine(e){return C(()=>({analysis:e,observer:this._observerEngineLocation,observerIntersection:this.analysis.intersection}),({analysis:t,observer:i,observerIntersection:s})=>{this._onObserverEngineForAnalysis(t,i,s)},$)}_connectAnalysisToCamera(e){return C(()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty}),({isDirty:t})=>{e.inputPoints.isValid&&!t||e.updateInputPoints()},we)}_connectAnalysisToElevation(e){return this.view.elevationProvider.on("elevation-change",t=>{if(!this._canComputeAnalysis(e))return;const i=this.analysis.observer;ge(t.extent,t.spatialReference,i)&&this._onObserverChange(i,this.analysis.intersection);const s=e.target;g(s)&&ge(t.extent,t.spatialReference,s.location)&&e.onElevationChange()})}_connectAnalysisForCompute(e){let t=Je;const i={analysis:e,interpolationInfo:{originalIntersection:y(),originalObserver:y(),originalTarget:y()}};return U([C(()=>this.getLineOfSightComputationDependencies(e),()=>{t=ye(t),t=qe(async s=>{await Ke(this._frameTask.schedule(()=>this.computeAnalysis(i),s))})},$),K(()=>t=ye(t))])}_connectAnalysis(e){const t=this._analysisHandles;t.has(e)||t.add([this._connectAnalysisToTarget(e),this._connectAnalysisToObserver(e),this._connectAnalysisToObserverEngine(e),this._connectAnalysisToCamera(e),this._connectAnalysisToElevation(e),this._connectAnalysisForCompute(e)],e)}_disconnectAnalysis(e){this._analysisHandles.remove(e)}_onAnalysesCollectionChange(e){e.added.forEach(t=>this._connectAnalysis(t)),e.removed.forEach(t=>this._disconnectAnalysis(t))}_onTargetsChange(){return this._analyses.removeAll(),this.analysis.targets.forEach(e=>this._addTarget(e)),this._updatingHandles.addOnCollectionPropertyChange(this.analysis,"targets",e=>this._onTargetCollectionChange(e))}_onTargetCollectionChange(e){e.added.forEach(t=>this._addTarget(t)),e.removed.forEach(t=>this._removeTarget(t))}_onCursorTargetChange(e,t){g(t)&&this._removeTarget(t),g(e)&&this._addTarget(e)}_addTarget(e){this._analyses.some(t=>t.target===e)||this._analyses.add(new H({target:e}))}_removeTarget(e){const t=this._analyses.find(i=>i.target===e);this._analyses.remove(t)}_connectObserver(){return U([C(()=>this.analysis.observer,e=>{ve(e,this.analysis.intersection)||(this.analysis.intersection=null)},pe),C(()=>({observer:this.analysis.observer,intersection:this.analysis.intersection}),({observer:e,intersection:t})=>this._onObserverChange(e,t),$)])}_connectAnalyses(){let e=null;return U([C(()=>this._analyses,()=>{F(e),e=this._updatingHandles.addOnCollectionPropertyChange(this,"_analyses",t=>this._onAnalysesCollectionChange(t)),this._analyses.forEach(t=>this._connectAnalysis(t))},$),K(()=>e=F(e))])}_connectTargets(){let e=null;return U([C(()=>this.analysis.targets,()=>{e=F(e),e=this._onTargetsChange()},$),C(()=>this.analysisViewData.cursorTarget,(t,i)=>{this._onCursorTargetChange(t,i)}),K(()=>{e=F(e)})])}get _isCameraDirty(){const e=this.analysisViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:i}=t;if(A(e)||A(i))return!1;const s=ee;i.toRenderCoords(e,s);const r=t.state.camera.computeScreenPixelSizeAt(s);return Math.abs((r-this._screenPixelSize)/this._screenPixelSize)>st}};function ge(e,t,i){return!A(i)&&(Me(e,t,_e,i.spatialReference),ke(_e,i))}function ve(e,t){return A(t)||g(e)&&e.equals(t.point)}n([o({constructOnly:!0})],f.prototype,"analysis",void 0),n([o({constructOnly:!0})],f.prototype,"analysisViewData",void 0),n([o({constructOnly:!0})],f.prototype,"view",void 0),n([o()],f.prototype,"updating",null),n([o()],f.prototype,"priority",null),n([o()],f.prototype,"_analyses",null),n([o()],f.prototype,"_observerEngineLocation",null),n([o()],f.prototype,"_screenPixelSize",null),n([o({readOnly:!0})],f.prototype,"_updatingHandles",void 0),n([o()],f.prototype,"_frameTask",void 0),n([o()],f.prototype,"_isCameraDirty",null),f=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightController")],f);const st=.1,ee=y(),nt=me(),_e=We();let O=class extends S{constructor(e){super(e),this.innerWidth=2,this.outerWidth=8,this.visibleInnerColor=new u([3,252,111,1]),this.visibleOuterColor=new u([3,252,111,.15]),this.occludedInnerColor=new u([252,3,69,1]),this.occludedOuterColor=new u([252,3,69,.1]),this.undefinedInnerColor=new u([255,255,255,1]),this.undefinedOuterColor=new u([127,127,127,.2])}};n([o({type:Number})],O.prototype,"innerWidth",void 0),n([o({type:Number})],O.prototype,"outerWidth",void 0),n([o({type:u})],O.prototype,"visibleInnerColor",void 0),n([o({type:u})],O.prototype,"visibleOuterColor",void 0),n([o({type:u})],O.prototype,"occludedInnerColor",void 0),n([o({type:u})],O.prototype,"occludedOuterColor",void 0),n([o({type:u})],O.prototype,"undefinedInnerColor",void 0),n([o({type:u})],O.prototype,"undefinedOuterColor",void 0),O=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightConfiguration")],O);let G=class extends S{constructor(){super(...arguments),this.analyses=new Ze,this.elevationAlignedObserver=null,this.configuration=new O,this.observerEngineLocation=y(),this.cursorTarget=null}};n([o()],G.prototype,"analyses",void 0),n([o()],G.prototype,"elevationAlignedObserver",void 0),n([o({type:O})],G.prototype,"configuration",void 0),n([o()],G.prototype,"observerEngineLocation",void 0),n([o()],G.prototype,"cursorTarget",void 0),G=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightViewData")],G);let V=class extends S{constructor(e){super(e),this._handle=null,this._analysisHandles=new ae}initialize(){this._handle=this._connectAnalyses()}destroy(){this._handle=F(this._handle),this._analysisHandles=k(this._analysisHandles)}get visible(){return this.analysisView.visible&&!this.analysisView.suspended}get _analyses(){return this.analysisView.analysisViewData.analyses}get _configuration(){return this.analysisView.analysisViewData.configuration}get _opacity(){return this.analysisView.fullOpacity}createLineOfSightVisualization(){const e=this._configuration,t=this._opacity,i={view:this.view,attached:!0,width:e.outerWidth,innerWidth:e.innerWidth},s=u.toUnitRGBA(e.visibleOuterColor);m(s,s,t);const r=u.toUnitRGBA(e.visibleInnerColor);m(r,r,t);const l=u.toUnitRGBA(e.occludedOuterColor);m(l,l,t);const a=u.toUnitRGBA(e.occludedInnerColor);m(a,a,t);const d=u.toUnitRGBA(e.undefinedOuterColor);m(d,d,t);const h=u.toUnitRGBA(e.undefinedInnerColor);return m(h,h,t),{visibleLineVisualElement:new ie(Q(Z({},i),{color:s,innerColor:r})),occludedLineVisualElement:new ie(Q(Z({},i),{color:l,innerColor:a})),undefinedLineVisualElement:new ie(Q(Z({},i),{color:d,innerColor:h}))}}destroyLineOfSightVisualization(e){e.visibleLineVisualElement=k(e.visibleLineVisualElement),e.occludedLineVisualElement=k(e.occludedLineVisualElement),e.undefinedLineVisualElement=k(e.undefinedLineVisualElement)}updateLineOfSightVisualization(e,t){const i=this.visible,s=this._configuration,{computationResult:r,inputPoints:l}=e,{start:a,end:d,intersection:h,isValid:_,isTargetVisible:c}=r,{observer:v}=l,L=lt;L[12]=v[0],L[13]=v[1],L[14]=v[2];const P=q(ot,a,v),B=q(rt,d,v),j=q(at,h,v),{visibleLineVisualElement:p,occludedLineVisualElement:z,undefinedLineVisualElement:b}=t;if(!i)return p.visible=!1,z.visible=!1,void(b.visible=!1);if(p.visible=!0,z.visible=!0,b.visible=!0,p.geometry=null,z.geometry=null,b.geometry=null,_)if(c){p.geometry=[[E(P),E(B)]],p.transform=L;const D=u.toUnitRGBA(s.visibleOuterColor);p.color=m(D,D,this._opacity)}else{p.geometry=[[E(P),E(j)]],p.transform=L;const D=u.toUnitRGBA(s.occludedOuterColor);p.color=m(D,D,this._opacity),z.geometry=[[E(j),E(B)]],z.transform=L}else b.geometry=[[E(P),E(B)]],b.transform=L}updateVisualizationOpacity(e,t){const i=this._configuration,s=this._opacity,r=u.toUnitRGBA(i.visibleOuterColor);m(r,r,s);const l=u.toUnitRGBA(i.visibleInnerColor);m(l,l,s);const a=u.toUnitRGBA(i.occludedOuterColor);m(a,a,s);const d=u.toUnitRGBA(i.occludedInnerColor);m(d,d,s);const h=u.toUnitRGBA(i.undefinedOuterColor);m(h,h,s);const _=u.toUnitRGBA(i.undefinedInnerColor);m(_,_,s),t.visibleLineVisualElement.color=e.computationResult.isTargetVisible?r:a,t.visibleLineVisualElement.innerColor=l,t.occludedLineVisualElement.color=a,t.occludedLineVisualElement.innerColor=d,t.undefinedLineVisualElement.color=h,t.undefinedLineVisualElement.innerColor=_}getLineOfSightVisualizationDependencies(e){const{computationResult:t}=e,{occludedOuterColor:i,visibleOuterColor:s}=this._configuration;return{computationResult:t,occludedOuterColor:i,visibleOuterColor:s,visible:this.visible}}_connectAnalysis(e){const t=this._analysisHandles;if(t.has(e))return;const i=this.createLineOfSightVisualization();t.add([C(()=>this.getLineOfSightVisualizationDependencies(e),()=>this.updateLineOfSightVisualization(e,i),$),C(()=>this._opacity,()=>this.updateVisualizationOpacity(e,i),we),K(()=>this.destroyLineOfSightVisualization(i))],e)}_disconnectAnalysis(e){this._analysisHandles.remove(e)}_connectAnalyses(){let e=null;return U([C(()=>this._analyses,t=>{e=F(e),e=t.on("change",i=>this._onAnalysesCollectionChange(i)),this._onAnalysesCollectionChange({target:t,added:t.items,removed:[],moved:[]})},$),K(()=>e=F(e))])}_onAnalysesCollectionChange(e){e.added.forEach(t=>this._connectAnalysis(t)),e.removed.forEach(t=>this._disconnectAnalysis(t))}};n([o({constructOnly:!0})],V.prototype,"analysis",void 0),n([o({constructOnly:!0})],V.prototype,"analysisView",void 0),n([o({constructOnly:!0})],V.prototype,"view",void 0),n([o({readOnly:!0})],V.prototype,"visible",null),n([o()],V.prototype,"_analyses",null),n([o()],V.prototype,"_configuration",null),n([o()],V.prototype,"_opacity",null),V=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")],V);const ot=y(),rt=y(),at=y(),lt=Qe();let w=class extends et(Xe(Ce.EventedMixin(S))){constructor(e){super(e),this.type="line-of-sight-view",this.suspended=!1,this.fullOpacity=1,this.analysisViewData=new G}initialize(){const e=this.view,t=this.analysis;this._analysisController=new f({analysis:t,analysisViewData:this.analysisViewData,view:e}),this._analysisVisualization=new V({analysis:t,analysisView:this,view:e}),this.handles.add([this._analysisController.on("result-changed",i=>{i.target!==this.analysisViewData.cursorTarget&&this.emit("result-changed",i)})])}destroy(){this._analysisController=k(this._analysisController),this._analysisVisualization=k(this._analysisVisualization)}get results(){return this.analysisViewData.analyses.map(e=>e.result)}get priority(){return this._analysisController.priority}set priority(e){this._analysisController.priority=e}get updating(){return g(this._analysisController)&&this._analysisController.updating}getResultForTarget(e){const t=this.analysisViewData.analyses.find(s=>s.target===e),i=Ye(t,s=>s.result);return be(i,null)}get test(){return{visualization:this._analysisVisualization,controller:this._analysisController}}};n([o()],w.prototype,"type",void 0),n([o()],w.prototype,"analysis",void 0),n([o({readOnly:!0})],w.prototype,"results",null),n([o()],w.prototype,"priority",null),n([o()],w.prototype,"suspended",void 0),n([o()],w.prototype,"fullOpacity",void 0),n([o()],w.prototype,"analysisViewData",void 0),n([o()],w.prototype,"updating",null),n([o()],w.prototype,"_analysisController",void 0),n([o()],w.prototype,"_analysisVisualization",void 0),w=n([R("esri.views.3d.analysis.LineOfSight.LineOfSightView3D")],w);const ht=w;export{ht as default};
