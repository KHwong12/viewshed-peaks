var Xe=Object.defineProperty,et=Object.defineProperties;var tt=Object.getOwnPropertyDescriptors;var ye=Object.getOwnPropertySymbols;var st=Object.prototype.hasOwnProperty,it=Object.prototype.propertyIsEnumerable;var ge=(n,e,t)=>e in n?Xe(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,W=(n,e)=>{for(var t in e||(e={}))st.call(e,t)&&ge(n,t,e[t]);if(ye)for(var t of ye(e))it.call(e,t)&&ge(n,t,e[t]);return n},xe=(n,e)=>et(n,tt(e));import{el as rt,em as at,en as C,eo as Ce,ep as de,eq as Ge,er as Z,r as G,b2 as nt,es as _e,x as I,t as v,d2 as ot,P as J,et as lt,eu as oe,ev as le,dD as ut,ew as ct,ex as we,ey as ue,ez as ce,eA as ht,eB as dt,eC as ft,eD as mt,eE as pt,eF as yt,eG as Se,eH as Ie,aN as Ne,eI as gt,eJ as xt,eK as ee,eL as Fe,eM as L,eN as _t,eO as wt,eP as St,eQ as It,a8 as De,eR as Ft,cW as Rt,ao as Re,f as be,dJ as j,d5 as bt,d6 as Tt,eS as vt,b6 as ie,am as Te,eT as At,dF as ve,eU as zt,aQ as Qt}from"./index.89a7b683.js";import{WhereClause as $t}from"./WhereClause.1d2917c7.js";import{t as je}from"./json.2d0d6862.js";import{t as Et}from"./QueryEngineCapabilities.83e56447.js";import{T as Vt,s as Mt,m as Ae,c as ze,V as Pt,g as Ct,h as Gt,y as Nt,D as Dt,z as jt,f as Ot,d as qt}from"./utils.2d48938c.js";const re=[0,0];function Oe(n,e){if(!e)return null;if("x"in e){const t={x:0,y:0};return[t.x,t.y]=n(e.x,e.y,re),e.z!=null&&(t.z=e.z),e.m!=null&&(t.m=e.m),t}if("xmin"in e){const t={xmin:0,ymin:0,xmax:0,ymax:0};return[t.xmin,t.ymin]=n(e.xmin,e.ymin,re),[t.xmax,t.ymax]=n(e.xmax,e.ymax,re),e.hasZ&&(t.zmin=e.zmin,t.zmax=e.zmax,t.hasZ=!0),e.hasM&&(t.mmin=e.mmin,t.mmax=e.mmax,t.hasM=!0),t}return"rings"in e?{rings:Qe(e.rings,n),hasM:e.hasM,hasZ:e.hasZ}:"paths"in e?{paths:Qe(e.paths,n),hasM:e.hasM,hasZ:e.hasZ}:"points"in e?{points:qe(e.points,n),hasM:e.hasM,hasZ:e.hasZ}:void 0}function Qe(n,e){const t=[];for(const s of n)t.push(qe(s,e));return t}function qe(n,e){const t=[];for(const s of n){const i=e(s[0],s[1],[0,0]);t.push(i),s.length>2&&i.push(s[2]),s.length>3&&i.push(s[3])}return t}async function B(n,e){if(!e)return;const t=Array.isArray(n)?n.map(s=>G(s.geometry)&&s.geometry.spatialReference):[n];await nt(t.map(s=>({source:s,dest:e})))}const Be=Oe.bind(null,rt),ke=Oe.bind(null,at);function N(n,e,t){return n&&(t||(t=e,e=n.spatialReference),Z(e)&&Z(t)&&!C(e,t)?Ce(e,t)?de(t)?Be(n):ke(n):Ge(je,[n],e,t,null)[0]:n)}class Bt{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,t,s){if(!e||!e.length||!t||!s||C(t,s))return e;const i={geometries:e,inSpatialReference:t,outSpatialReference:s,resolve:null};return this._jobs.push(i),new Promise(r=>{i.resolve=r,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:t,inSpatialReference:s,outSpatialReference:i,resolve:r}=e;Ce(s,i)?de(i)?r(t.map(Be)):r(t.map(ke)):r(Ge(je,t,s,i,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const kt=new Bt;function Zt(n,e,t){return kt.push(n,e,t)}class Ut{constructor(e,t){this._cache=new _e(e),this._invalidCache=new _e(t)}get(e,t){const s=`${t.uid}:${e}`,i=this._cache.get(s);if(i)return i;if(this._invalidCache.get(s)!==void 0)return null;try{const r=$t.create(e,t);return this._cache.put(s,r),r}catch{return this._invalidCache.put(s,null),null}}}const fe=new Ut(50,500),E="feature-store:unsupported-query",Ze=" as ",Lt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Jt(n,e){if(!e)return!0;const t=fe.get(e,n);if(!t)throw new I(E,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new I(E,"where clause is not standard",{where:e});return $(n,t.fieldNames,"where clause contains missing fields"),!0}function Ht(n,e,t){if(!e)return!0;const s=fe.get(e,n);if(!s)throw new I(E,"invalid SQL expression",{having:e});if(!s.isAggregate)throw new I(E,"having does not contain a valid aggregate function",{having:e});const i=s.fieldNames;if($(n,i,"having contains missing fields"),!s.getExpressions().every(r=>{const{aggregateType:a,field:o}=r,l=n.has(o)&&n.get(o).name;return t.some(u=>{const{onStatisticField:c,statisticType:h}=u;return(n.has(c)&&n.get(c).name)===l&&h.toLowerCase().trim()===a})}))throw new I(E,"expressions in having should also exist in outStatistics",{having:e});return!0}function q(n,e){return n?fe.get(n,e):null}function $(n,e,t,s=!0){const i=[];for(const r of e)if(r!=="*"&&!n.has(r))if(s){const a=Ue(r);try{const o=q(a,n);if(!o)throw new I(E,"invalid SQL expression",{where:a});if(!o.isStandardized)throw new I(E,"expression is not standard",{clause:o});$(n,o.fieldNames,"expression contains missing fields")}catch(o){const l=o&&o.details;if(l&&(l.clause||l.where))throw o;l&&l.missingFields?i.push(...l.missingFields):i.push(r)}}else i.push(r);if(i.length)throw new I(E,t,{missingFields:i})}function Ue(n){return n.split(Ze)[0]}function Yt(n){return n.split(Ze)[1]}function Wt(n,e){const t=e.get(n);return!!t&&!Lt.has(t.type)}class K{constructor(e,t,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=s,this.featureAdapter=t;const i=e.outFields;if(i&&i.indexOf("*")===-1){this.outFields=i;let r=0;for(const a of i){const o=Ue(a),l=this.fieldsIndex.get(o),u=l?null:q(o,s),c=l?l.name:Yt(a)||"FIELD_EXP_"+r++;this._fieldDataCache.set(a,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,s){const i=s?s.name:t;let r=null;return this._fieldDataCache.has(i)?r=this._fieldDataCache.get(i).clause:s||(r=q(t,this.fieldsIndex),this._fieldDataCache.set(i,{alias:i,clause:r})),s?this.featureAdapter.getAttribute(e,i):r.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const s=t.normalizationType,i=t.normalizationTotal;let r=this.getFieldValue(e,t.field,t.fieldInfo);if(s&&Number.isFinite(r)){const a=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);r=Vt(r,s,a,i)}return r}getExpressionValue(e,t,s){const i={attributes:this.featureAdapter.getAttributes(e)},r=s.createExecContext(i,t.viewInfo);return s.executeFunction(t.compiledFunc,r)}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:q(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:q(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const s={};for(const i of t){const{alias:r,clause:a}=this._fieldDataCache.get(i);s[r]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,r)}return s}_processAttributesForDistinctValues(e){if(v(e)||!this.returnDistinctValues)return e;const t=this.outFields,s=[];if(t)for(const a of t){const{alias:o}=this._fieldDataCache.get(a);s.push(e[o])}else for(const a in e)s.push(e[a]);const i=`${(t||["*"]).join(",")}=${s.join(",")}`;let r=this._returnDistinctMap.get(i)||0;return this._returnDistinctMap.set(i,++r),r>1?null:e}}function Kt(n,e){if(!n)return null;const t=e.featureAdapter,{startTimeField:s,endTimeField:i}=n;let r=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(s&&i)e.forEach(o=>{const l=t.getAttribute(o,s),u=t.getAttribute(o,i);l==null||isNaN(l)||(r=Math.min(r,l)),u==null||isNaN(u)||(a=Math.max(a,u))});else{const o=s||i;e.forEach(l=>{const u=t.getAttribute(l,o);u==null||isNaN(u)||(r=Math.min(r,u),a=Math.max(a,u))})}return{start:r,end:a}}function Xt(n,e,t){if(!e||!n)return null;const{startTimeField:s,endTimeField:i}=n;if(!s&&!i)return null;const{start:r,end:a}=e;return r===null&&a===null?null:r===void 0&&a===void 0?ss():s&&i?es(t,s,i,r,a):ts(t,s||i,r,a)}function es(n,e,t,s,i){return s!=null&&i!=null?r=>{const a=n.getAttribute(r,e),o=n.getAttribute(r,t);return(a==null||a<=i)&&(o==null||o>=s)}:s!=null?r=>{const a=n.getAttribute(r,t);return a==null||a>=s}:i!=null?r=>{const a=n.getAttribute(r,e);return a==null||a<=i}:void 0}function ts(n,e,t,s){return t!=null&&s!=null&&t===s?i=>n.getAttribute(i,e)===t:t!=null&&s!=null?i=>{const r=n.getAttribute(i,e);return r>=t&&r<=s}:t!=null?i=>n.getAttribute(i,e)>=t:s!=null?i=>n.getAttribute(i,e)<=s:void 0}function ss(){return()=>!1}const is=new ot({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),Q=Object.freeze({}),$e=new J,rs=new J,he=new J,ae={esriGeometryPoint:ce,esriGeometryPolyline:ft,esriGeometryPolygon:mt,esriGeometryMultipoint:pt};function Ee(n,e,t,s=n.hasZ,i=n.hasM){if(v(e))return null;const r=n.hasZ&&s,a=n.hasM&&i;if(t){const o=ue(he,e,n.hasZ,n.hasM,"esriGeometryPoint",t,s,i);return ce(o,r,a)}return ce(e,r,a)}function P(n,e,t,s,i,r,a=e,o=t){const l=e&&a,u=t&&o,c=G(s)?"coords"in s?s:s.geometry:null;if(v(c))return null;if(i){let h=ht(rs,c,e,t,n,i,a,o);return r&&(h=ue(he,h,l,u,n,r)),ae[n](h,l,u)}if(r){const h=ue(he,c,e,t,n,r,a,o);return ae[n](h,l,u)}return dt($e,c,e,t,a,o),ae[n]($e,l,u)}async function O(n,e,t){const{outFields:s,orderByFields:i,groupByFieldsForStatistics:r,outStatistics:a}=n;if(s)for(let o=0;o<s.length;o++)s[o]=s[o].trim();if(i)for(let o=0;o<i.length;o++)i[o]=i[o].trim();if(r)for(let o=0;o<r.length;o++)r[o]=r[o].trim();if(a)for(let o=0;o<a.length;o++)a[o].onStatisticField&&(a[o].onStatisticField=a[o].onStatisticField.trim());return n.geometry&&!n.outSR&&(n.outSR=n.geometry.spatialReference),as(n,e,t)}async function as(n,e,t){if(!n)return null;let{where:s}=n;if(n.where=s=s&&s.trim(),(!s||/^1 *= *1$/.test(s)||e&&e===s)&&(n.where=null),!n.geometry)return n;let i=await ns(n);if(n.distance=0,n.units=null,n.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:l}=n.geometry;i=lt(i),i.spatialReference=l}n.geometry=i,await B(i.spatialReference,t);const r=(await oe(le(i)))[0];if(v(r))throw Q;const a=r.toJSON(),o=await N(a,a.spatialReference,t);if(!o)throw Q;return o.spatialReference=t,n.geometry=o,n}async function ns(n){const{geometry:e,distance:t,units:s}=n;if(t==null||"vertexAttributes"in e)return e;const i=e.spatialReference,r=s?is.fromJSON(s):ut(i),a=i&&(ct(i)||de(i))?e:await B(i,we).then(()=>N(e,we));return(await os())(a.spatialReference,a,t,r)}async function os(){return(await import("./geometryEngineJSON.1787cb60.js")).geodesicBuffer}function k(n){return n&&Le in n?JSON.parse(JSON.stringify(n,ls)):n}const Le="_geVersion",ls=(n,e)=>n!==Le?e:void 0;class F{constructor(e,t,s){this.items=e,this.queryGeometry=t,this.definitionExpression=s.definitionExpression,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.fieldsIndex=s.fieldsIndex,this.timeInfo=s.timeInfo,this.featureAdapter=s.featureAdapter,this.aggregateAdapter=s.aggregateAdapter}get size(){return this.items.length}createQueryResponseForCount(e){const t=new K(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:s,having:i}=e;if(!(s!=null&&s.length))return 1;const r=new Map,a=new Map,o=new Set,l=e.outStatistics;for(const u of l){const{statisticType:c}=u,h=c!=="exceedslimit"?u.onStatisticField:void 0;if(!a.has(h)){const p=[];for(const d of s){const _=this._getAttributeValues(t,d,r);p.push(_)}a.set(h,this._calculateUniqueValues(p,t.returnDistinctValues))}const f=a.get(h);for(const p in f){const{data:d,items:_}=f[p],m=d.join(",");i&&!t.validateItems(_,i)||o.add(m)}}return o.size}createQueryResponse(e){let t;return e.outStatistics?t=e.outStatistics.some(s=>s.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(e):this._createStatisticsQueryResponse(e):t=this._createFeatureQueryResponse(e),e.returnQueryGeometry&&(Z(e.outSR)&&!C(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=k(W({spatialReference:e.outSR},N(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR))):t.queryGeometry=k(W({spatialReference:e.outSR},this.queryGeometry))),t}createSnappingResponse(e,t){const s=this.featureAdapter,i=cs(this.hasZ,this.hasM),{x:r,y:a}=e.point,o=typeof e.distance=="number"?e.distance:e.distance.x,l=typeof e.distance=="number"?e.distance:e.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this.getPointCreator(e.point,this.spatialReference,t);for(const f of this.items){const p=s.getGeometry(f);if(v(p))continue;const{coords:d,lengths:_}=p;if(1&e.types){let m=0;for(let y=0;y<_.length;y++){const S=_[y];for(let w=0;w<S;w++,m+=i){const R=d[m],x=d[m+1];if(w!==S-1){const g=d[m+i],b=d[m+i+1],{x:H,y:A}=us(r,a,R,x,g,b),V=(r-H)/o,D=(a-A)/l,M=V*V+D*D;M<=1&&u.candidates.push({type:"edge",objectId:s.getObjectId(f),distance:Math.sqrt(M),target:h(H,A),start:h(R,x),end:h(g,b)})}}}}if(2&e.types){const m=c?d.length-i:d.length;for(let y=0;y<m;y+=i){const S=d[y],w=d[y+1],R=(r-S)/o,x=(a-w)/l,g=R*R+x*x;g<=1&&u.candidates.push({type:"vertex",objectId:s.getObjectId(f),distance:Math.sqrt(g),target:h(S,w)})}}}return u.candidates.sort((f,p)=>f.distance-p.distance),u}getPointCreator(e,t,s){const i=G(s)&&!C(t,s)?r=>N(r,t,s):r=>r;return e.z!=null&&e.m!=null?(r,a)=>i({x:r,y:a,z:e.z,m:e.m}):e.z!=null?(r,a)=>i({x:r,y:a,z:e.z}):e.m!=null?(r,a)=>i({x:r,y:a,m:e.m}):(r,a)=>i({x:r,y:a})}executeAttributesQuery(e){const t=q(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let s=0;const i=[];for(const a of this.items)t.testFeature(a,this.featureAdapter)&&(i[s++]=a);const r=new F(i,this.queryGeometry,this);return r.definitionExpression=e.where,Promise.resolve(r)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(e){if(!e.aggregateIds||!e.aggregateIds.length||v(this.aggregateAdapter))return Promise.resolve(this);const t=new Set;for(const i of e.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach(r=>t.add(r));const s=this.featureAdapter.getObjectId;return Promise.resolve(new F(this.items.filter(i=>t.has(s(i))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),s=this.featureAdapter.getObjectId;return Promise.resolve(new F(this.items.filter(i=>t.has(s(i))),this.queryGeometry,this))}executeTimeQuery(e){const t=Xt(this.timeInfo,e.timeExtent,this.featureAdapter);if(!G(t))return Promise.resolve(this);const s=this.items.filter(t);return Promise.resolve(new F(s,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:s}=this.timeInfo,i=s||t,r=new Map,a=this.featureAdapter.getAttribute;for(const l of this.items){const u=a(l,e),c=a(l,i),h=r.get(u);(!h||c>a(h,i))&&r.set(u,l)}const o=Array.from(r.values());return Promise.resolve(new F(o,this.queryGeometry,this))}async project(e){if(!e||C(this.spatialReference,e))return this;const t=this.featureAdapter,s=(await Zt(this.items.map(i=>P(this.geometryType,this.hasZ,this.hasM,t.getGeometry(i))),this.spatialReference,e)).map((i,r)=>t.cloneWithGeometry(this.items[r],yt(i,this.hasZ,this.hasM)));return new F(s,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:s,valueExpression:i,normalizationField:r,normalizationType:a,normalizationTotal:o,minValue:l,maxValue:u,scale:c}=t,h=this.fieldsIndex.isDateField(s),f=await this._getDataValues(e,{field:s,valueExpression:i,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:c}),p=Mt({normalizationType:a,normalizationField:r,minValue:l,maxValue:u}),d=this.fieldsIndex.get(s),_={value:.5,fieldType:d==null?void 0:d.type},m=Se(d)?Ae({values:f,supportsNullCount:p,percentileParams:_}):ze({values:f,minValue:l,maxValue:u,useSampleStdDev:!a,supportsNullCount:p,percentileParams:_});return Pt(m,h)}async createUniqueValuesResponse(e,t){const{field:s,valueExpression:i,domain:r,returnAllCodedValues:a,scale:o}=t,l=await this._getDataValues(e,{field:s,valueExpression:i,scale:o}),u=Ct(l);return Gt(u,r,a)}async createClassBreaksResponse(e,t){const{field:s,valueExpression:i,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numClasses:f,scale:p}=t,d=await this._getDataValues(e,{field:s,valueExpression:i,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:p}),_=Nt(d,{field:s,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numClasses:f});return Dt(_,l)}async createHistogramResponse(e,t){const{field:s,valueExpression:i,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numBins:f,scale:p}=t,d=await this._getDataValues(e,{field:s,valueExpression:i,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:p});return jt(d,{field:s,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numBins:f})}_sortFeatures(e,t,s){if(e.length>1&&t&&t.length)for(const i of t.reverse()){const r=i.split(" "),a=r[0],o=this.fieldsIndex.get(a),l=r[1]&&r[1].toLowerCase()==="desc",u=Ot(o==null?void 0:o.type,l);e.sort((c,h)=>{const f=s(c,a,o),p=s(h,a,o);return u(f,p)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:i,hasZ:r,objectIdField:a,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:f,returnZ:p,returnM:d}=e,_=h!=null&&t.length>(f||0)+h,m=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:_,features:this._createFeatures(e,t),fields:m,geometryType:s,hasM:i&&d,hasZ:r&&p,objectIdFieldName:a,spatialReference:k(u||o),transform:c&&Ie(c)||null}}_createFeatures(e,t){const s=new K(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:r}=this,{orderByFields:a,quantizationParameters:o,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:h,resultRecordCount:f,returnZ:p=!1,returnM:d=!1}=e,_=r&&p,m=i&&d;let y=[],S=0;const w=[...t];if(this._sortFeatures(w,a,(x,g,b)=>s.getFieldValue(x,g,b)),l||u){const x=Ie(o);if(l&&!u)for(const g of w)y[S++]={attributes:s.getAttributes(g),geometry:P(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,x,_,m)};else if(!l&&u)for(const g of w)y[S++]={attributes:s.getAttributes(g),centroid:Ee(this,this.featureAdapter.getCentroid(g,this),x)};else for(const g of w)y[S++]={attributes:s.getAttributes(g),centroid:Ee(this,this.featureAdapter.getCentroid(g,this),x),geometry:P(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,x,_,m)}}else for(const x of w){const g=s.getAttributes(x);g&&(y[S++]={attributes:g})}const R=h||0;if(f!=null){const x=R+f;y=y.slice(R,Math.min(y.length,x))}return y}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const a of e.outStatistics)if(a.statisticType==="exceedslimit"){s=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,i=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,r=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>s;else if(this.items.length>i)t=!0;else{const a=this.hasZ?this.hasM?4:3:this.hasM?3:2,o=this.featureAdapter;t=this.items.reduce((l,u)=>{const c=o.getGeometry(u);return l+(G(c)&&c.coords.length||0)},0)/a>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}_createStatisticsQueryResponse(e){const t={attributes:{}},s=[],i=new Map,r=new Map,a=new Map,o=new Map,l=new K(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:f}=e,p=c&&c.length,d=!!p,_=d&&c[0],m=d&&!this.fieldsIndex.get(_);for(const S of u){const{outStatisticFieldName:w,statisticType:R}=S,x=S,g=R!=="exceedslimit"?S.onStatisticField:void 0,b=R==="percentile_disc"||R==="percentile_cont",H=d&&p===1&&(g===_||m)&&R==="count";if(d){if(!a.has(g)){const V=[];for(const D of c){const M=this._getAttributeValues(l,D,i);V.push(M)}a.set(g,this._calculateUniqueValues(V,l.returnDistinctValues))}const A=a.get(g);for(const V in A){const{count:D,data:M,items:Ye,itemPositions:We}=A[V],pe=M.join(",");if(!h||l.validateItems(Ye,h)){const te=o.get(pe)||{attributes:{}};let se=null;if(H)se=D;else{const Y=this._getAttributeValues(l,g,i),U=We.map(Ke=>Y[Ke]);se=b&&"statisticParameters"in x?this._getPercentileValue(x,U):this._getStatisticValue(x,U,null,l.returnDistinctValues)}te.attributes[w]=se,c.forEach((Y,U)=>te.attributes[this.fieldsIndex.get(Y)?Y:`EXPR_${U+1}`]=M[U]),o.set(pe,te)}}}else{const A=this._getAttributeValues(l,g,i);t.attributes[w]=b&&"statisticParameters"in x?this._getPercentileValue(x,A):this._getStatisticValue(x,A,r,l.returnDistinctValues)}s.push({name:w,alias:w,type:"esriFieldTypeDouble"})}const y=d?Array.from(o.values()):[t];return this._sortFeatures(y,f,(S,w)=>S.attributes[w]),{fields:s,features:y}}_getStatisticValue(e,t,s,i){const{onStatisticField:r,statisticType:a}=e;let o=null;return o=s!=null&&s.has(r)?s.get(r):Se(this.fieldsIndex.get(r))?Ae({values:t,returnDistinct:i}):ze({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(r,o),o[a==="var"?"variance":a]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:r}=e,{value:a,orderBy:o}=i,l=this.fieldsIndex.get(s),u={value:a,orderBy:o,fieldType:l==null?void 0:l.type,isDiscrete:r==="percentile_disc"};return qt(t,u)}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const i=this.fieldsIndex.get(t),r=this.items.map(a=>e.getFieldValue(a,t,i));return s.set(t,r),r}_getAttributeNormalizedValues(e,t){return this.items.map(s=>e.getNormalizedValue(s,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,s){const{arcadeUtils:i}=await Ne(),r=i.createFunction(t),a=s&&i.getViewInfo(s);return this.items.map(o=>e.getExpressionValue(o,{compiledFunc:r,viewInfo:a},i))}_calculateUniqueValues(e,t){const s={},i=this.items,r=i.length;for(let a=0;a<r;a++){const o=i[a],l=[];for(const c of e)l.push(c[a]);const u=l.join(",");t?s[u]==null&&(s[u]={count:1,data:l,items:[o],itemPositions:[a]}):s[u]==null?s[u]={count:1,data:l,items:[o],itemPositions:[a]}:(s[u].count++,s[u].items.push(o),s[u].itemPositions.push(a))}return s}async _getDataValues(e,t){const s=new K(e,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:r,normalizationField:a,normalizationType:o,normalizationTotal:l,scale:u}=t,c=i?{viewingMode:"map",scale:u,spatialReference:e.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(s,i,c):this._getAttributeNormalizedValues(s,{field:r,normalizationField:a,normalizationType:o,normalizationTotal:l})}}function us(n,e,t,s,i,r){const a=i-t,o=r-s,l=a*a+o*o,u=(n-t)*a+(e-s)*o,c=Math.min(1,Math.max(0,u/l));return{x:t+a*c,y:s+o*c}}function cs(n,e){return n?e?4:3:e?3:2}function hs(n){return n==="mesh"?gt:xt(n)}function Je(n,e){return n?e?4:3:e?3:2}function ds(n,e,t,s){return He(n,e,t,s.coords[0],s.coords[1])}function fs(n,e,t,s,i,r){const a=Je(i,r),{coords:o,lengths:l}=s;if(!l)return!1;for(let u=0,c=0;u<l.length;u++,c+=a)if(!He(n,e,t,o[c],o[c+1]))return!1;return!0}function He(n,e,t,s,i){if(!n)return!1;const r=Je(e,t),{coords:a,lengths:o}=n;let l=!1,u=0;for(const c of o)l=ms(l,a,r,u,c,s,i),u+=c*r;return l}function ms(n,e,t,s,i,r,a){let o=n,l=s;for(let u=s,c=s+i*t;u<c;u+=t){l=u+t,l===c&&(l=s);const h=e[u],f=e[u+1],p=e[l],d=e[l+1];(f<a&&d>=a||d<a&&f>=a)&&h+(a-f)/(d-f)*(p-h)<r&&(o=!o)}return o}const ne="feature-store:unsupported-query",ps={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},me={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function ys(n){return me.spatialRelationship[n]===!0}function gs(n){return me.queryGeometry[St(n)]===!0}function xs(n){return me.layerGeometry[n]===!0}function _s(){return import("./geometryEngineJSON.1787cb60.js")}function Ve(n,e,t,s,i){if(ee(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains")){const r=Fe(new J,e,!1,!1);return Promise.resolve(a=>ds(r,!1,!1,a))}if(ee(e)&&t==="esriGeometryMultipoint"){const r=Fe(new J,e,!1,!1);if(n==="esriSpatialRelContains")return Promise.resolve(a=>fs(r,!1,!1,a,s,i))}if(L(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains"))return Promise.resolve(r=>_t(e,P(t,s,i,r)));if(L(e)&&t==="esriGeometryMultipoint"&&n==="esriSpatialRelContains")return Promise.resolve(r=>wt(e,P(t,s,i,r)));if(L(e)&&n==="esriSpatialRelIntersects"){const r=hs(t);return Promise.resolve(a=>r(e,P(t,s,i,a)))}return _s().then(r=>{const a=r[ps[n]].bind(null,e.spatialReference,e);return o=>a(P(t,s,i,o))})}async function Me(n,e,t){const{spatialRel:s,geometry:i}=n;if(i){if(!ys(s))throw new I(ne,"Unsupported query spatial relationship",{query:n});if(Z(i.spatialReference)&&Z(t)){if(!gs(i))throw new I(ne,"Unsupported query geometry type",{query:n});if(!xs(e))throw new I(ne,"Unsupported layer geometry type",{query:n});if(n.outSR)return B(n.geometry&&n.geometry.spatialReference,n.outSR)}}}function Pe(n){if(L(n))return!0;if(ee(n)){for(const e of n.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}function ws(n){return n.every(e=>e.statisticType!=="exceedslimit")}const z="feature-store:unsupported-query",X=new Set,Ss=new It(2e6);let Is=0;class Qs{constructor(e){this.capabilities={query:Et},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new Ft(Is+++"$$",Ss)),this.fieldsIndex=new Rt(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=Re(this._frameTask),this.clearCache(),be(this._geometryQueryCache),this._changeHandle=Re(this._changeHandle),be(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:k(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=Kt(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let s,i=j(e);try{i=await this._schedule(()=>O(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t)}catch(r){if(r!==Q)throw r;s=new F([],null,this)}return s.createQueryResponse(i)}async executeQueryForCount(e={},t){let s=j(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>O(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t);let i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t);return i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i.createQueryResponseForCount(s)}catch(i){if(i!==Q)throw i;return 0}}async executeQueryForExtent(e={},t){let s,i=j(e);const r=i.outSR;try{i=await this._schedule(()=>O(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),i.returnGeometry=!0,i.returnCentroid=!1,i.outSR=null,s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const a=s.size;if(!a)return{count:a,extent:null};bt(T,Tt),this.featureStore.forEachBounds(s.items,u=>vt(T,u),Fs);const o={xmin:T[0],ymin:T[1],xmax:T[3],ymax:T[4],spatialReference:k(this.spatialReference)};this.hasZ&&isFinite(T[2])&&isFinite(T[5])&&(o.zmin=T[2],o.zmax=T[5]);const l=N(o,s.spatialReference,r);if(l.spatialReference=k(r||this.spatialReference),l.xmax-l.xmin==0){const u=ie(l.spatialReference);l.xmin-=u,l.xmax+=u}if(l.ymax-l.ymin==0){const u=ie(l.spatialReference);l.ymin-=u,l.ymax+=u}if(this.hasZ&&l.zmin!=null&&l.zmax!=null&&l.zmax-l.zmin==0){const u=ie(l.spatialReference);l.zmin-=u,l.zmax+=u}return{count:a,extent:l}}catch(a){if(a===Q)return{count:0,extent:null};throw a}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(s=>Array.from(s))}async executeQueryForIdSet(e={},t){let s,i=j(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>O(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const r=s.items,a=new Set;return await this._reschedule(()=>{for(const o of r)a.add(s.featureAdapter.getObjectId(o))},t),a}catch(r){if(r===Q)return new Set;throw r}}async executeQueryForSnapping(e,t){const{point:s,distance:i,types:r}=e;if(r===0)return{candidates:[]};const a=await this._reschedule(()=>this._checkQuerySupport(e.query),t),o=!C(s.spatialReference,this.spatialReference);o&&await B(s.spatialReference,this.spatialReference);const l=typeof i=="number"?i:i.x,u=typeof i=="number"?i:i.y,c={xmin:s.x-l,xmax:s.x+l,ymin:s.y-u,ymax:s.y+u,spatialReference:s.spatialReference},h=o?N(c,this.spatialReference):c;if(!h)return{candidates:[]};const f=(await oe(le(s),null,{signal:t}))[0],p=(await oe(le(h),null,{signal:t}))[0];if(v(f)||v(p))return{candidates:[]};let d=new F(this._searchFeatures(this._getQueryBBoxes(p.toJSON())),null,this);d=await this._reschedule(()=>d.executeObjectIdsQuery(a),t),d=await this._reschedule(()=>d.executeTimeQuery(a),t),d=await this._reschedule(()=>d.executeAttributesQuery(a),t);const _=f.toJSON(),m=o?N(_,this.spatialReference):_,y=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:i;return d.createSnappingResponse(xe(W({},e),{point:m,distance:y}),s.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new I(z,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let s,i=j(e);try{i=await this._schedule(()=>O(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s=await this._reschedule(()=>s.filterLatest(),t)}catch(r){if(r!==Q)throw r;s=new F([],null,this)}return s.createQueryResponse(i)}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,valueExpression:r},s)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createHistogramResponse(e,t)}async _schedule(e,t){return G(this._frameTask)?this._frameTask.schedule(e,t):e(Te)}async _reschedule(e,t){return G(this._frameTask)?this._frameTask.reschedule(e,t):e(Te)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new F(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:s,outSR:i,spatialRel:r,returnGeometry:a,returnCentroid:o}=e,l=a||o,u=Z(i)&&!C(this.spatialReference,i),c=this._geometryQueryCache?u&&l?JSON.stringify({geometry:s,spatialRelationship:r,outSpatialReference:i}):JSON.stringify({geometry:s,spatialRelationship:r}):null;if(c){const m=this._geometryQueryCache.get(c);if(!At(m))return m}const h=async m=>{if(u&&l){const y=await m.project(i);return c&&this._geometryQueryCache.put(c,y,y.size||1),y}return c&&this._geometryQueryCache.put(c,m,m.size||1),m};if(!s)return h(this._getAll());const f=this.featureAdapter;if(r==="esriSpatialRelDisjoint"){const m=this._searchFeatures(this._getQueryBBoxes(s));if(!m.length)return h(this._getAll());let y,S;const w=new Set;for(const x of m)w.add(f.getObjectId(x));await this._reschedule(()=>{let x=0;y=new Array(w.size),this.featureStore.forEach(g=>y[x++]=g),S=w},t);const R=await this._reschedule(async()=>{const x=await Ve(r,s,this.geometryType,this.hasZ,this.hasM),g=b=>!S.has(f.getObjectId(b))||x(f.getGeometry(b));return new F(await this._runSpatialFilter(y,g,t),s,this)},t);return h(R)}const p=this._searchFeatures(this._getQueryBBoxes(s));if(!p.length){const m=new F([],s,this);return c&&this._geometryQueryCache.put(c,m,m.size||1),m}if(this._canExecuteSoloPass(s,e))return h(new F(p,s,this));const d=await Ve(r,s,this.geometryType,this.hasZ,this.hasM),_=await this._runSpatialFilter(p,m=>d(f.getGeometry(m)),t);return h(new F(_,s,this))}async _runSpatialFilter(e,t,s){if(!t)return e;if(v(this._frameTask))return e.filter(o=>t(o));let i=0;const r=new Array,a=async o=>{for(;i<e.length;){const l=e[i++];t(l)&&(r.push(l),o.madeProgress()),o.done&&await this._reschedule(u=>a(u),s)}};return this._reschedule(o=>a(o),s).then(()=>r)}_canExecuteSoloPass(e,t){const{geometryType:s}=this,{spatialRel:i}=t;return Pe(e)&&(i==="esriSpatialRelEnvelopeIntersects"||s==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"||i==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(Pe(e)){if(L(e))return[ve(e.xmin,e.ymin,e.xmax,e.ymax)];if(ee(e))return e.rings.map(t=>ve(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[zt(Qt(),e)]}_searchFeatures(e){for(const i of e)this.featureStore.forEachInBounds(i,r=>{X.add(r)});const t=new Array(X.size);let s=0;return X.forEach(i=>t[s++]=i),X.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new I(z,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),Me(e,this.geometryType,this.spatialReference),B(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:s}=await Ne();t=s.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new I(z,"params should have at least a field or valueExpression",{params:e});$(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new I(z,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Me(e,this.geometryType,this.spatialReference),B(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:i,outStatistics:r}=e,a=r?r.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()):[];if(s&&s.length>0){const o=" asc",l=" desc",u=s.map(c=>{const h=c.toLowerCase();return h.indexOf(o)>-1?h.split(o)[0]:h.indexOf(l)>-1?h.split(l)[0]:c}).filter(c=>a.indexOf(c)===-1);$(this.fieldsIndex,u,"orderByFields contains missing fields")}if(t&&t.length>0)$(this.fieldsIndex,t,"outFields contains missing fields");else if(i)throw new I(z,"outFields should be specified for returnDistinctValues",{query:e});Jt(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:i}=e,r=s&&s.length,a=t&&t.length;if(i){if(!r||!a)throw new I(z,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});Ht(this.fieldsIndex,i,t)}if(a){if(!ws(t))return;const o=t.map(l=>l.onStatisticField);$(this.fieldsIndex,o,"onStatisticFields contains missing fields"),r&&$(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const l of t){const{onStatisticField:u,statisticType:c}=l;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in l){const{statisticParameters:h}=l;if(!h)throw new I(z,"statisticParamters should be set for percentile type",{definition:l,query:e})}else if(c!=="count"&&u&&Wt(u,this.fieldsIndex))throw new I(z,"outStatistics contains non-numeric fields",{definition:l,query:e})}}}async _getQueryEngineResultForStats(e={},t,s){let i;e=j(e);try{e=await this._schedule(()=>O(e,this.definitionExpression,this.spatialReference),s),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),s),i=await this._reschedule(()=>this._executeGeometryQuery(e,s),s),i=await this._reschedule(()=>i.executeAggregateIdsQuery(e),s),i=await this._reschedule(()=>i.executeObjectIdsQuery(e),s),i=await this._reschedule(()=>i.executeTimeQuery(e),s),i=await this._reschedule(()=>i.executeAttributesQuery(e),s)}catch(r){if(r!==Q)throw r;i=new F([],null,this)}return i}}const Fs=De(),T=De();export{Qs as L,as as Z,B as f,N as g,Xt as n,Ve as v};
